{"version":3,"file":"js/chunk-vendors-b8e726d7.6063a0af.js","mappings":"2HA2CA,SAASA,EAAwBC,GAC/B,OAAqC,MAA9BA,EAAqC,EAAIA,EAA2BC,QAAU,CACvF,CAEA,SAASC,EAAiBC,GACxB,OAAOA,CACT,CAEA,IAAIC,EAEJ,WAIE,SAASA,EAAWC,EAAQC,EAAQC,EAAcC,EAAcC,EAChEC,GACEC,KAAKC,KAAOP,EACZM,KAAKE,KAAOP,EACZK,KAAKG,cAAgBP,GAAgBL,EACrCS,KAAKI,cAAgBP,GAAgBN,EAErCS,KAAKF,QAAUA,EACfE,KAAKK,kBAAiC,aAAbN,CAC3B,CA+NA,OAzNAN,EAAWa,UAAUC,IAAM,SAAUC,GAEnC,OADAR,KAAKS,KAAOD,EACLR,IACT,EAMAP,EAAWa,UAAUI,OAAS,SAAUF,GAEtC,OADAR,KAAKW,QAAUH,EACRR,IACT,EAMAP,EAAWa,UAAUM,gBAAkB,SAAUJ,GAE/C,OADAR,KAAKa,iBAAmBL,EACjBR,IACT,EAMAP,EAAWa,UAAUQ,gBAAkB,SAAUN,GAE/C,OADAR,KAAKe,iBAAmBP,EACjBR,IACT,EAMAP,EAAWa,UAAUU,iBAAmB,SAAUR,GAEhD,OADAR,KAAKiB,kBAAoBT,EAClBR,IACT,EAMAP,EAAWa,UAAUY,OAAS,SAAUV,GAEtC,OADAR,KAAKmB,QAAUX,EACRR,IACT,EAEAP,EAAWa,UAAUc,QAAU,WAC7BpB,KAAKA,KAAKK,kBAAoB,mBAAqB,qBACrD,EAEAZ,EAAWa,UAAUe,iBAAmB,WACtC,IAAI3B,EAASM,KAAKC,KACdN,EAASK,KAAKE,KACdoB,EAAkB,CAAC,EACnBC,EAAgB,IAAIC,MAAM9B,EAAOJ,QACjCmC,EAAgB,IAAID,MAAM7B,EAAOL,QAErCU,KAAK0B,cAAchC,EAAQ,KAAM6B,EAAe,iBAEhDvB,KAAK0B,cAAc/B,EAAQ2B,EAAiBG,EAAe,iBAE3D,IAAK,IAAIE,EAAI,EAAGA,EAAIjC,EAAOJ,OAAQqC,IAAK,CACtC,IAAIC,EAASL,EAAcI,GACvBE,EAAeP,EAAgBM,GAC/BE,EAAkB1C,EAAwByC,GAE9C,GAAIC,EAAkB,EAAG,CAGvB,IAAIC,EAASF,EAAaG,QAEE,IAAxBH,EAAavC,SACfgC,EAAgBM,GAAUC,EAAa,IAGzC7B,KAAKW,SAAWX,KAAKW,QAAQoB,EAAQJ,EACvC,MAA+B,IAApBG,GACTR,EAAgBM,GAAU,KAC1B5B,KAAKW,SAAWX,KAAKW,QAAQkB,EAAcF,IAE3C3B,KAAKmB,SAAWnB,KAAKmB,QAAQQ,EAEjC,CAEA3B,KAAKiC,gBAAgBR,EAAeH,EACtC,EA4BA7B,EAAWa,UAAU4B,iBAAmB,WACtC,IAAIxC,EAASM,KAAKC,KACdN,EAASK,KAAKE,KACdiC,EAAkB,CAAC,EACnBb,EAAkB,CAAC,EACnBC,EAAgB,GAChBE,EAAgB,GAEpBzB,KAAK0B,cAAchC,EAAQyC,EAAiBZ,EAAe,iBAE3DvB,KAAK0B,cAAc/B,EAAQ2B,EAAiBG,EAAe,iBAE3D,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAcjC,OAAQqC,IAAK,CAC7C,IAAIC,EAASL,EAAcI,GACvBS,EAAeD,EAAgBP,GAC/BC,EAAeP,EAAgBM,GAC/BS,EAAkBjD,EAAwBgD,GAC1CN,EAAkB1C,EAAwByC,GAE9C,GAAIQ,EAAkB,GAAyB,IAApBP,EACzB9B,KAAKa,kBAAoBb,KAAKa,iBAAiBgB,EAAcO,GAC7Dd,EAAgBM,GAAU,UACrB,GAAwB,IAApBS,GAAyBP,EAAkB,EACpD9B,KAAKe,kBAAoBf,KAAKe,iBAAiBc,EAAcO,GAC7Dd,EAAgBM,GAAU,UACrB,GAAwB,IAApBS,GAA6C,IAApBP,EAClC9B,KAAKW,SAAWX,KAAKW,QAAQkB,EAAcO,GAC3Cd,EAAgBM,GAAU,UACrB,GAAIS,EAAkB,GAAKP,EAAkB,EAClD9B,KAAKiB,mBAAqBjB,KAAKiB,kBAAkBY,EAAcO,GAC/Dd,EAAgBM,GAAU,UACrB,GAAIS,EAAkB,EAC3B,IAAK,IAAIC,EAAM,EAAGA,EAAMD,EAAiBC,IACvCtC,KAAKmB,SAAWnB,KAAKmB,QAAQiB,EAAaE,SAG5CtC,KAAKmB,SAAWnB,KAAKmB,QAAQiB,EAEjC,CAEApC,KAAKiC,gBAAgBR,EAAeH,EACtC,EAEA7B,EAAWa,UAAU2B,gBAAkB,SAAUR,EAAeH,GAC9D,IAAK,IAAIK,EAAI,EAAGA,EAAIF,EAAcnC,OAAQqC,IAAK,CAC7C,IAAIY,EAASd,EAAcE,GACvBE,EAAeP,EAAgBiB,GAC/BC,EAAepD,EAAwByC,GAE3C,GAAIW,EAAe,EACjB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAcC,IAChCzC,KAAKS,MAAQT,KAAKS,KAAKoB,EAAaY,SAEZ,IAAjBD,GACTxC,KAAKS,MAAQT,KAAKS,KAAKoB,GAIzBP,EAAgBiB,GAAU,IAC5B,CACF,EAEA9C,EAAWa,UAAUoB,cAAgB,SAAUgB,EAC/CC,EAGAC,EAAQC,GAGN,IAFA,IAAIC,EAAiB9C,KAAKK,kBAEjBsB,EAAI,EAAGA,EAAIe,EAAIpD,OAAQqC,IAAK,CAEnC,IAAIoB,EAAM,OAAS/C,KAAK6C,GAAeH,EAAIf,GAAIA,GAM/C,GAJKmB,IACHF,EAAOjB,GAAKoB,GAGTJ,EAAL,CAIA,IAAIK,EAAYL,EAAII,GAChBP,EAAepD,EAAwB4D,GAEtB,IAAjBR,GAGFG,EAAII,GAAOpB,EAEPmB,GACFF,EAAOK,KAAKF,IAEY,IAAjBP,EACTG,EAAII,GAAO,CAACC,EAAWrB,GAEvBqB,EAAUC,KAAKtB,EAhBjB,CAkBF,CACF,EAEOlC,CACT,CA7OA,GA+OA,Q,mICjOIyD,E,iCArBAC,EAAY,YAKLC,SAAyBC,cAAgBF,EAAY3B,MAAQ6B,YAC7DC,SAAyBC,cAAgBJ,EAAY3B,MAAQ+B,YAC7DC,SAAwBC,aAAeN,EAAY3B,MAAQiC,WAC3DC,SAA0BC,eAAiBR,EAAY3B,MAAQmC,aAKtEC,EAAY,CACd,MAASF,EACT,IAAOF,EAEP,QAAWhC,MACX,OAAUA,MACV,KAAQkC,GAIV,SAASG,EAAeC,GAEtB,OAAOA,EAAW,MAAQV,EAAkBE,CAC9C,CAIA,SAASS,IACP,MAAO,CAACC,KAAWA,IACrB,CAIA,SAASC,EAAWC,GAClB,IAAIC,EAAOD,EAAcE,YAEzB,OAAOD,IAAS3C,MAAQ0C,EAAcG,QAAU,IAAIF,EAAKD,EAC3D,CAEA,SAASI,EAAaC,EAAOC,EAAQC,EAASC,EAAKC,GACjD,IAAIC,EAAWhB,EAAUa,GAAW,SAEpC,GAAIE,EAAQ,CACV,IAAIE,EAAWN,EAAMC,GACjBM,EAASD,GAAYA,EAASvF,OAElC,GAAMwF,IAAWJ,EAAM,CAIrB,IAHA,IAAIK,EAAW,IAAIH,EAASF,GAGnBjC,EAAI,EAAGA,EAAIqC,EAAQrC,IAC1BsC,EAAStC,GAAKoC,EAASpC,GAGzB8B,EAAMC,GAAUO,CAClB,CACF,MACER,EAAMC,GAAU,IAAII,EAASF,EAEjC,CAOA,IAAIM,EAEJ,WACE,SAASA,IACPhF,KAAKiF,QAAU,GAEfjF,KAAKkF,WAAa,GAClBlF,KAAKmF,QAAU,GACfnF,KAAKoF,OAAS,EACdpF,KAAKqF,UAAY,EACjBrF,KAAKsF,mBAAoBC,EAAAA,EAAAA,gBAC3B,CA2jCA,OArjCAP,EAAU1E,UAAUkF,SAAW,SAAUC,EAAUC,EAAiBC,GAKlE3F,KAAK4F,UAAYH,EAEjBzF,KAAKiF,QAAU,GACfjF,KAAK6F,SAAW,KAChB7F,KAAK8F,YAAc9F,KAAK+F,mBACxB,IAAIC,EAASP,EAASQ,YAClBC,EAAgBlG,KAAKmG,sBAAwBjD,EAAuB8C,EAAOI,cAE/EpG,KAAKqG,gBAAkBV,GAAkBO,EAEzClG,KAAKkF,WAAa,IACWoB,EAAAA,EAAAA,IAAyBN,GACtDhG,KAAKuG,aAAc5D,EAAAA,EAAAA,KAAI+C,GAAiB,SAAUc,GAOhD,MAAO,CAELC,KAAMD,EAAIC,KACVC,SAAUF,EAAIE,SAElB,IAEA1G,KAAK2G,sBAAsB,EAAGlB,EAASmB,QACzC,EAEA5B,EAAU1E,UAAUuG,YAAc,WAChC,OAAO7G,KAAK4F,SACd,EAUAZ,EAAU1E,UAAU2F,UAAY,WAC9B,OAAOjG,KAAK4F,UAAUK,WACxB,EAMAjB,EAAU1E,UAAUwG,2BAA6B,SAAUC,EAASN,GAClE,IAAIO,EAAmBhH,KAAKsF,kBACxB2B,EAAajH,KAAKuG,YAClBW,EAAaF,EAAiBG,IAAIJ,GAEtC,GAAkB,MAAdG,GACF,GAAID,EAAWC,GAAYT,OAASA,EAClC,OAAOS,OAGTA,EAAaD,EAAW3H,OAS1B,OANA2H,EAAWC,GAAc,CACvBT,KAAMA,GAERO,EAAiBI,IAAIL,EAASG,GAC9BlH,KAAKiF,QAAQiC,GAAc,IAAItD,EAAU6C,GAAQ,SAASzG,KAAKqF,WAC/DrF,KAAKkF,WAAWgC,GAAcnD,IACvBmD,CACT,EAEAlC,EAAU1E,UAAU+G,mBAAqB,SAAU7C,EAAQ8C,GACzD,IAAIC,EAAQvH,KAAKiF,QAAQT,GACrBgC,EAAMxG,KAAKuG,YAAY/B,GACvBgD,EAAaxH,KAAKkF,WAClBuC,EAASjB,EAAIkB,eAAiB,EAC9BC,EAAMJ,EAAMjI,OAED,IAAXmI,IAGFD,EAAWhD,GAAUT,KAKvB,IAFA,IAAI6D,EAAeJ,EAAWhD,GAErB7C,EAAI8F,EAAQ9F,EAAIgG,EAAKhG,IAAK,CACjC,IAAIkG,EAAMN,EAAM5F,GAAK2F,EAAYQ,gBAAgBP,EAAM5F,IAElDoG,MAAMF,KACTD,EAAa,GAAKI,KAAKC,IAAIJ,EAAKD,EAAa,IAC7CA,EAAa,GAAKI,KAAKE,IAAIL,EAAKD,EAAa,IAEjD,CAEApB,EAAIc,YAAcA,EAClBd,EAAIkB,cAAgBC,EACpBnB,EAAIC,KAAO,SACb,EAEAzB,EAAU1E,UAAU6H,eAAiB,SAAU3D,GAC7C,IAAI4D,EAAUpI,KAAKuG,YAAY/B,GAC3B8C,EAAcc,EAAQd,YAC1B,OAAOA,CACT,EAEAtC,EAAU1E,UAAU+H,qBAAuB,SAAUC,GACnD,IAAI9I,EAAOQ,KAAKuG,YAAY+B,GAC5B,OAAO9I,GAAQA,EAAKkH,QACtB,EAMA1B,EAAU1E,UAAUiI,WAAa,SAAUC,GAKzC,IAAI/C,EAAWzF,KAAK4F,UAChB6C,EAAQzI,KAAK4G,QACjBnB,EAAS8C,WAAWC,GACpB,IAAI9D,EAAMe,EAASmB,QAUnB,OARKnB,EAASiD,aACZhE,GAAO+D,GAGLA,EAAQ/D,GACV1E,KAAK2G,sBAAsB8B,EAAO/D,GAAK,GAGlC,CAAC+D,EAAO/D,EACjB,EAEAM,EAAU1E,UAAUqI,aAAe,SAAUC,EAAQC,GAQnD,IAPA,IAAIC,EAAS9I,KAAKiF,QACdgC,EAAajH,KAAKuG,YAClBwC,EAAS9B,EAAW3H,OACpB0J,EAAYhJ,KAAKkF,WACjBuD,EAAQzI,KAAK4G,QACblC,EAAM+D,EAAQT,KAAKE,IAAIU,EAAOtJ,OAAQuJ,GAAc,GAE/ClH,EAAI,EAAGA,EAAIoH,EAAQpH,IAAK,CAC/B,IAAI6E,EAAMS,EAAWtF,GACrB2C,EAAawE,EAAQnH,EAAG6E,EAAIC,KAAM/B,GAAK,EACzC,CAIA,IAFA,IAAIuE,EAAgB,GAEXC,EAAMT,EAAOS,EAAMxE,EAAKwE,IAG/B,IAFA,IAAIC,EAAYD,EAAMT,EAEbjE,EAAS,EAAGA,EAASuE,EAAQvE,IAAU,CAC1CgC,EAAMS,EAAWzC,GAArB,IACIqD,EAAM3E,EAAuBkG,UAAUC,KAAKrJ,KAAM4I,EAAOO,IAAcF,EAAezC,EAAIE,SAAUyC,EAAW3E,GACnHsE,EAAOtE,GAAQ0E,GAAOrB,EACtB,IAAID,EAAeoB,EAAUxE,GAC7BqD,EAAMD,EAAa,KAAOA,EAAa,GAAKC,GAC5CA,EAAMD,EAAa,KAAOA,EAAa,GAAKC,EAC9C,CAIF,OADA7H,KAAKqF,UAAYrF,KAAKoF,OAASV,EACxB,CACL+D,MAAOA,EACP/D,IAAKA,EAET,EAEAM,EAAU1E,UAAUqG,sBAAwB,SAAU8B,EAAO/D,EAAKC,GAUhE,IATA,IAAIc,EAAWzF,KAAK4F,UAChBkD,EAAS9I,KAAKiF,QACdgC,EAAajH,KAAKuG,YAClBwC,EAAS9B,EAAW3H,OACpB0J,EAAYhJ,KAAKkF,WACjBoE,GAAW3G,EAAAA,EAAAA,KAAIsE,GAAY,SAAUT,GACvC,OAAOA,EAAIE,QACb,IAES/E,EAAI,EAAGA,EAAIoH,EAAQpH,IAAK,CAC/B,IAAI6E,EAAMS,EAAWtF,GAEhBqH,EAAUrH,KACbqH,EAAUrH,GAAKoC,KAGjBO,EAAawE,EAAQnH,EAAG6E,EAAIC,KAAM/B,EAAKC,EACzC,CAEA,GAAIc,EAAS8D,YACX9D,EAAS8D,YAAYd,EAAO/D,EAAKoE,EAAQE,QAIzC,IAFA,IAAIQ,EAAW,GAENN,EAAMT,EAAOS,EAAMxE,EAAKwE,IAAO,CAEtCM,EAAW/D,EAASgE,QAAQP,EAAKM,GAQjC,IAAK,IAAIhF,EAAS,EAAGA,EAASuE,EAAQvE,IAAU,CAC9C,IAAIkF,EAAaZ,EAAOtE,GAEpBqD,EAAM7H,KAAKqG,gBAAgBmD,EAAUF,EAAS9E,GAAS0E,EAAK1E,GAEhEkF,EAAWR,GAAOrB,EAClB,IAAID,EAAeoB,EAAUxE,GAC7BqD,EAAMD,EAAa,KAAOA,EAAa,GAAKC,GAC5CA,EAAMD,EAAa,KAAOA,EAAa,GAAKC,EAC9C,CACF,EAGGpC,EAASiD,YAAcjD,EAASkE,OAEnClE,EAASkE,QAGX3J,KAAKqF,UAAYrF,KAAKoF,OAASV,EAE/B1E,KAAKmF,QAAU,EACjB,EAEAH,EAAU1E,UAAUsG,MAAQ,WAC1B,OAAO5G,KAAKoF,MACd,EAMAJ,EAAU1E,UAAU6G,IAAM,SAAUX,EAAK0C,GACvC,KAAMA,GAAO,GAAKA,EAAMlJ,KAAKoF,QAC3B,OAAOwE,IAGT,IAAIC,EAAW7J,KAAKiF,QAAQuB,GAC5B,OAAOqD,EAAWA,EAAS7J,KAAK8F,YAAYoD,IAAQU,GACtD,EAEA5E,EAAU1E,UAAUwJ,UAAY,SAAU7C,EAAYiC,GACpD,IAAIN,EAAS,GACTmB,EAAS,GAEb,GAAW,MAAPb,EAAa,CACfA,EAAMjC,EAENA,EAAa,GAEb,IAAK,IAAItF,EAAI,EAAGA,EAAI3B,KAAKuG,YAAYjH,OAAQqC,IAC3CoI,EAAO9G,KAAKtB,EAEhB,MACEoI,EAAS9C,EAGFtF,EAAI,EAAb,IAAK,IAAWgG,EAAMoC,EAAOzK,OAAQqC,EAAIgG,EAAKhG,IAC5CiH,EAAO3F,KAAKjD,KAAKmH,IAAI4C,EAAOpI,GAAIuH,IAGlC,OAAON,CACT,EAMA5D,EAAU1E,UAAU0J,cAAgB,SAAUxD,EAAKyD,GACjD,KAAMA,GAAU,GAAKA,EAASjK,KAAKqF,WACjC,OAAOuE,IAGT,IAAIC,EAAW7J,KAAKiF,QAAQuB,GAC5B,OAAOqD,EAAWA,EAASI,GAAUL,GACvC,EAMA5E,EAAU1E,UAAU4J,OAAS,SAAU1D,GACrC,IAAI2D,EAAUnK,KAAKiF,QAAQuB,GACvB4D,EAAM,EAEV,GAAID,EACF,IAAK,IAAIxI,EAAI,EAAGgG,EAAM3H,KAAK4G,QAASjF,EAAIgG,EAAKhG,IAAK,CAChD,IAAI0I,EAAQrK,KAAKmH,IAAIX,EAAK7E,GAErBoG,MAAMsC,KACTD,GAAOC,EAEX,CAGF,OAAOD,CACT,EAMApF,EAAU1E,UAAUgK,UAAY,SAAU9D,GACxC,IAAI+D,EAAe,GAEnBvK,KAAKwK,KAAK,CAAChE,IAAM,SAAUqB,GACpBE,MAAMF,IACT0C,EAAatH,KAAK4E,EAEtB,IAGA,IAAI4C,EAAqBF,EAAaG,MAAK,SAAUC,EAAGC,GACtD,OAAOD,EAAIC,CACb,IACIjD,EAAM3H,KAAK4G,QAEf,OAAe,IAARe,EAAY,EAAIA,EAAM,IAAM,EAAI8C,GAAoB9C,EAAM,GAAK,IAAM8C,EAAmB9C,EAAM,GAAK8C,EAAmB9C,EAAM,EAAI,IAAM,CAC/I,EAMA3C,EAAU1E,UAAUuK,gBAAkB,SAAUC,GAC9C,GAAIA,GAAY9K,KAAKqF,WAAayF,EAAW,EAC3C,OAAQ,EAGV,IAAK9K,KAAK6F,SACR,OAAOiF,EAIT,IAAIC,EAAU/K,KAAK6F,SAEfmF,EAAeD,EAAQD,GAE3B,GAAoB,MAAhBE,GAAwBA,EAAehL,KAAKoF,QAAU4F,IAAiBF,EACzE,OAAOA,EAGT,IAAIG,EAAO,EACPC,EAAQlL,KAAKoF,OAAS,EAE1B,MAAO6F,GAAQC,EAAO,CACpB,IAAIC,GAAOF,EAAOC,GAAS,EAAI,EAE/B,GAAIH,EAAQI,GAAOL,EACjBG,EAAOE,EAAM,MACR,MAAIJ,EAAQI,GAAOL,GAGxB,OAAOK,EAFPD,EAAQC,EAAM,CAGhB,CACF,CAEA,OAAQ,CACV,EAWAnG,EAAU1E,UAAU8K,iBAAmB,SAAU5E,EAAK6D,EAAOgB,GAC3D,IAAIvC,EAAS9I,KAAKiF,QACdkF,EAAUrB,EAAOtC,GACjB8E,EAAiB,GAErB,IAAKnB,EACH,OAAOmB,EAGU,MAAfD,IACFA,EAAcrH,KAOhB,IAJA,IAAIuH,EAAUvH,IACVwH,GAAW,EACXC,EAAoB,EAEf9J,EAAI,EAAGgG,EAAM3H,KAAK4G,QAASjF,EAAIgG,EAAKhG,IAAK,CAChD,IAAI+J,EAAY1L,KAAK8F,YAAYnE,GAC7BgK,EAAOtB,EAAQF,EAAQuB,GACvBE,EAAO5D,KAAK6D,IAAIF,GAEhBC,GAAQP,KAONO,EAAOL,GAAWK,IAASL,GAAWI,GAAQ,GAAKH,EAAU,KAC/DD,EAAUK,EACVJ,EAAUG,EACVF,EAAoB,GAGlBE,IAASH,IACXF,EAAeG,KAAuB9J,GAG5C,CAGA,OADA2J,EAAehM,OAASmM,EACjBH,CACT,EAEAtG,EAAU1E,UAAUwL,WAAa,WAC/B,IAAIC,EACAhB,EAAU/K,KAAK6F,SAEnB,GAAIkF,EAAS,CACX,IAAI5G,EAAO4G,EAAQ3G,YACf4H,EAAYhM,KAAKoF,OAErB,GAAIjB,IAAS3C,MAAO,CAClBuK,EAAa,IAAI5H,EAAK6H,GAEtB,IAAK,IAAIrK,EAAI,EAAGA,EAAIqK,EAAWrK,IAC7BoK,EAAWpK,GAAKoJ,EAAQpJ,EAE5B,MACEoK,EAAa,IAAI5H,EAAK4G,EAAQkB,OAAQ,EAAGD,EAE7C,KAAO,CACD7H,EAAON,EAAe7D,KAAKqF,WAC/B0G,EAAa,IAAI5H,EAAKnE,KAAK4G,SAE3B,IAASjF,EAAI,EAAGA,EAAIoK,EAAWzM,OAAQqC,IACrCoK,EAAWpK,GAAKA,CAEpB,CAEA,OAAOoK,CACT,EAMA/G,EAAU1E,UAAU4L,OAAS,SAAUC,EAAMC,GAC3C,IAAKpM,KAAKoF,OACR,OAAOpF,KAaT,IAVA,IAAI+E,EAAW/E,KAAKqM,QAChBzF,EAAQ7B,EAAS6B,QACjBzC,EAAON,EAAekB,EAASM,WAC/B0G,EAAa,IAAI5H,EAAKyC,GACtByD,EAAQ,GACRiC,EAAUH,EAAK7M,OACfmI,EAAS,EACT8E,EAAOJ,EAAK,GACZrD,EAAS/D,EAASE,QAEbtD,EAAI,EAAGA,EAAIiF,EAAOjF,IAAK,CAC9B,IAAI6K,OAAO,EACPvC,EAASlF,EAASe,YAAYnE,GAElC,GAAgB,IAAZ2K,EACFE,EAAOJ,EAAGzK,QACL,GAAgB,IAAZ2K,EAAe,CACxB,IAAIzE,EAAMiB,EAAOyD,GAAMtC,GACvBuC,EAAOJ,EAAGvE,EAAKlG,EACjB,KAAO,CAGL,IAFA,IAAI8K,EAAI,EAEDA,EAAIH,EAASG,IAClBpC,EAAMoC,GAAK3D,EAAOqD,EAAKM,IAAIxC,GAG7BI,EAAMoC,GAAK9K,EACX6K,EAAOJ,EAAGM,MAAM,KAAMrC,EACxB,CAEImC,IACFT,EAAWtE,KAAYwC,EAE3B,CAaA,OAVIxC,EAASb,IACX7B,EAASc,SAAWkG,GAGtBhH,EAASK,OAASqC,EAElB1C,EAASI,QAAU,GAEnBJ,EAAS4H,mBAEF5H,CACT,EAOAC,EAAU1E,UAAUsM,YAAc,SAAUC,GAC1C,IAAI9H,EAAW/E,KAAKqM,QAChB1E,EAAM5C,EAASK,OAEnB,IAAKuC,EACH,OAAO3H,KAGT,IAAImM,GAAOW,EAAAA,EAAAA,MAAKD,GACZP,EAAUH,EAAK7M,OAEnB,IAAKgN,EACH,OAAOtM,KAGT,IAAI+M,EAAgBhI,EAAS6B,QACzBzC,EAAON,EAAekB,EAASM,WAC/B0G,EAAa,IAAI5H,EAAK4I,GACtBtF,EAAS,EACT8E,EAAOJ,EAAK,GACZlE,EAAM4E,EAAMN,GAAM,GAClBrE,EAAM2E,EAAMN,GAAM,GAClBS,EAAWjI,EAASE,QACpBgI,GAAgB,EAEpB,IAAKlI,EAASc,SAAU,CAEtB,IAAIqD,EAAM,EAEV,GAAgB,IAAZoD,EAAe,CAGjB,IAFA,IAAI5C,EAAasD,EAASb,EAAK,IAEtBxK,EAAI,EAAGA,EAAIgG,EAAKhG,IAAK,CAC5B,IAAIkG,EAAM6B,EAAW/H,IAMjBkG,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MACpCkE,EAAWtE,KAAYyB,GAGzBA,GACF,CAEA+D,GAAgB,CAClB,MAAO,GAAgB,IAAZX,EAAe,CACpB5C,EAAasD,EAASb,EAAK,IAA/B,IACIe,EAAcF,EAASb,EAAK,IAC5BgB,EAAON,EAAMV,EAAK,IAAI,GACtBiB,EAAOP,EAAMV,EAAK,IAAI,GAE1B,IAASxK,EAAI,EAAGA,EAAIgG,EAAKhG,IAAK,CACxBkG,EAAM6B,EAAW/H,GAArB,IACI0L,EAAOH,EAAYvL,IAElBkG,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MAAUwF,GAAQF,GAAQE,GAAQD,GAAQrF,MAAMsF,MACrFtB,EAAWtE,KAAYyB,GAGzBA,GACF,CAEA+D,GAAgB,CAClB,CACF,CAEA,IAAKA,EACH,GAAgB,IAAZX,EACF,IAAS3K,EAAI,EAAGA,EAAIoL,EAAepL,IAAK,CACtC,IAAImJ,EAAW/F,EAASe,YAAYnE,GAChCkG,EAAMmF,EAASb,EAAK,IAAIrB,IAExBjD,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MACpCkE,EAAWtE,KAAYqD,EAE3B,MAEA,IAASnJ,EAAI,EAAGA,EAAIoL,EAAepL,IAAK,CAItC,IAHA,IAAI6K,GAAO,EAGFC,GAFL3B,EAAW/F,EAASe,YAAYnE,GAEvB,GAAG8K,EAAIH,EAASG,IAAK,CAChC,IAAIa,EAAOnB,EAAKM,GACZ5E,EAAMmF,EAASM,GAAMxC,IAErBjD,EAAMgF,EAAMS,GAAM,IAAMzF,EAAMgF,EAAMS,GAAM,MAC5Cd,GAAO,EAEX,CAEIA,IACFT,EAAWtE,KAAY1C,EAASe,YAAYnE,GAEhD,CAeJ,OAVI8F,EAASsF,IACXhI,EAASc,SAAWkG,GAGtBhH,EAASK,OAASqC,EAElB1C,EAASI,QAAU,GAEnBJ,EAAS4H,mBAEF5H,CACT,EAgBAC,EAAU1E,UAAUqC,IAAM,SAAUwJ,EAAMC,GAExC,IAAImB,EAASvN,KAAKqM,MAAMF,GAIxB,OAFAnM,KAAKwN,YAAYD,EAAQpB,EAAMC,GAExBmB,CACT,EAMAvI,EAAU1E,UAAUmN,OAAS,SAAUtB,EAAMC,GAC3CpM,KAAKwN,YAAYxN,KAAMmM,EAAMC,EAC/B,EAEApH,EAAU1E,UAAUkN,YAAc,SAAUD,EAAQpB,EAAMC,GAQxD,IAPA,IAAIsB,EAAeH,EAAOtI,QACtB0I,EAAc,GACdrB,EAAUH,EAAK7M,OACfsO,EAAYL,EAAO3G,QACnBgC,EAAS,GACTI,EAAYuE,EAAOrI,WAEdvD,EAAI,EAAGA,EAAIwK,EAAK7M,OAAQqC,IAC/BqH,EAAUmD,EAAKxK,IAAMoC,IAGvB,IAAK,IAAI2H,EAAY,EAAGA,EAAYkC,EAAWlC,IAAa,CAG1D,IAFA,IAAIZ,EAAWyC,EAAOzH,YAAY4F,GAEzBe,EAAI,EAAGA,EAAIH,EAASG,IAC3B7D,EAAO6D,GAAKiB,EAAavB,EAAKM,IAAI3B,GAGpClC,EAAO0D,GAAWZ,EAClB,IAAImC,EAAWzB,GAAMA,EAAGM,MAAM,KAAM9D,GAEpC,GAAgB,MAAZiF,EAAkB,CAEI,kBAAbA,IACTF,EAAY,GAAKE,EACjBA,EAAWF,GAGb,IAAShM,EAAI,EAAGA,EAAIkM,EAASvO,OAAQqC,IAAK,CACxC,IAAI6E,EAAM2F,EAAKxK,GACXkG,EAAMgG,EAASlM,GACfmM,EAAiB9E,EAAUxC,GAC3BqD,EAAW6D,EAAalH,GAExBqD,IACFA,EAASiB,GAAYjD,GAGnBA,EAAMiG,EAAe,KACvBA,EAAe,GAAKjG,GAGlBA,EAAMiG,EAAe,KACvBA,EAAe,GAAKjG,EAExB,CACF,CACF,CACF,EAQA7C,EAAU1E,UAAUyN,eAAiB,SAAUC,EAAgBC,GAC7D,IAOIC,EACAC,EACAC,EATAb,EAASvN,KAAKqM,MAAM,CAAC2B,IAAiB,GACtCK,EAAgBd,EAAOtI,QACvB4E,EAAWwE,EAAcL,GACzBrG,EAAM3H,KAAK4G,QACX0H,EAAe,EACfC,EAAYvG,KAAKwG,MAAM,EAAIP,GAC3BQ,EAAkBzO,KAAK8F,YAAY,GAInCiG,EAAa,IAAKlI,EAAe7D,KAAKqF,WAAzB,CAAqC2C,KAAKC,IAAuC,GAAlCD,KAAK0G,KAAK/G,EAAM4G,GAAa,GAAQ5G,IAErGoE,EAAWuC,KAAkBG,EAE7B,IAAK,IAAI9M,EAAI,EAAGA,EAAIgG,EAAM,EAAGhG,GAAK4M,EAAW,CAM3C,IALA,IAAII,EAAiB3G,KAAKC,IAAItG,EAAI4M,EAAW5G,EAAM,GAC/CiH,EAAe5G,KAAKC,IAAItG,EAAgB,EAAZ4M,EAAe5G,GAC3CkH,GAAQD,EAAeD,GAAkB,EACzCG,EAAO,EAEF5F,EAAMyF,EAAgBzF,EAAM0F,EAAc1F,IAAO,CACxD,IAAI4B,EAAW9K,KAAK8F,YAAYoD,GAC5B6F,EAAIlF,EAASiB,GAEb/C,MAAMgH,KAIVD,GAAQC,EACV,CAEAD,GAAQF,EAAeD,EACvB,IAAIK,EAAarN,EACbsN,EAAWjH,KAAKC,IAAItG,EAAI4M,EAAW5G,GACnCuH,EAAUvN,EAAI,EACdwN,EAAUtF,EAAS4E,GACvBP,GAAW,EACXE,EAAeY,EACf,IAAII,GAAiB,EACjBC,EAAW,EAGf,IAASnG,EAAM8F,EAAY9F,EAAM+F,EAAU/F,IAAO,CAC5C4B,EAAW9K,KAAK8F,YAAYoD,GAC5B6F,EAAIlF,EAASiB,GAEb/C,MAAMgH,IACRM,IAEID,EAAgB,IAClBA,EAAgBtE,KAOpBqD,EAAOnG,KAAK6D,KAAKqD,EAAUL,IAASE,EAAII,IAAYD,EAAUhG,IAAQ4F,EAAOK,IAEzEhB,EAAOD,IACTA,EAAUC,EACVC,EAAetD,GAEnB,CAEIuE,EAAW,GAAKA,EAAWJ,EAAWD,IAGxCjD,EAAWuC,KAAkBtG,KAAKC,IAAImH,EAAehB,GACrDA,EAAepG,KAAKE,IAAIkH,EAAehB,IAGzCrC,EAAWuC,KAAkBF,EAC7BK,EAAkBL,CACpB,CAOA,OAJArC,EAAWuC,KAAkBtO,KAAK8F,YAAY6B,EAAM,GACpD4F,EAAOnI,OAASkJ,EAChBf,EAAO1H,SAAWkG,EAClBwB,EAAOzH,YAAc9F,KAAKsP,WACnB/B,CACT,EAOAvI,EAAU1E,UAAUiP,WAAa,SAAUC,EAAWvB,EAAMwB,EAAaC,GAWvE,IAVA,IAAInC,EAASvN,KAAKqM,MAAM,CAACmD,IAAY,GACjCnB,EAAgBd,EAAOtI,QACvB0K,EAAc,GACdpB,EAAYvG,KAAKwG,MAAM,EAAIP,GAC3BpE,EAAWwE,EAAcmB,GACzB7H,EAAM3H,KAAK4G,QACXkH,EAAiBP,EAAOrI,WAAWsK,GAAazL,IAChDgI,EAAa,IAAKlI,EAAe7D,KAAKqF,WAAzB,CAAqC2C,KAAK0G,KAAK/G,EAAM4G,IAClE9G,EAAS,EAEJ9F,EAAI,EAAGA,EAAIgG,EAAKhG,GAAK4M,EAAW,CAEnCA,EAAY5G,EAAMhG,IACpB4M,EAAY5G,EAAMhG,EAClBgO,EAAYrQ,OAASiP,GAGvB,IAAK,IAAI9B,EAAI,EAAGA,EAAI8B,EAAW9B,IAAK,CAClC,IAAImD,EAAU5P,KAAK8F,YAAYnE,EAAI8K,GACnCkD,EAAYlD,GAAK5C,EAAS+F,EAC5B,CAEA,IAAIvF,EAAQoF,EAAYE,GACpBE,EAAiB7P,KAAK8F,YAAYkC,KAAKC,IAAItG,EAAI+N,EAAYC,EAAatF,IAAU,EAAG1C,EAAM,IAE/FkC,EAASgG,GAAkBxF,EAEvBA,EAAQyD,EAAe,KACzBA,EAAe,GAAKzD,GAGlBA,EAAQyD,EAAe,KACzBA,EAAe,GAAKzD,GAGtB0B,EAAWtE,KAAYoI,CACzB,CAOA,OALAtC,EAAOnI,OAASqC,EAChB8F,EAAO1H,SAAWkG,EAElBwB,EAAOZ,mBAEAY,CACT,EAWAvI,EAAU1E,UAAUkK,KAAO,SAAU2B,EAAMC,GACzC,GAAKpM,KAAKoF,OAOV,IAHA,IAAIkH,EAAUH,EAAK7M,OACfwJ,EAAS9I,KAAKiF,QAETtD,EAAI,EAAGgG,EAAM3H,KAAK4G,QAASjF,EAAIgG,EAAKhG,IAAK,CAChD,IAAIsI,EAASjK,KAAK8F,YAAYnE,GAE9B,OAAQ2K,GACN,KAAK,EACHF,EAAGzK,GACH,MAEF,KAAK,EACHyK,EAAGtD,EAAOqD,EAAK,IAAIlC,GAAStI,GAC5B,MAEF,KAAK,EACHyK,EAAGtD,EAAOqD,EAAK,IAAIlC,GAASnB,EAAOqD,EAAK,IAAIlC,GAAStI,GACrD,MAEF,QAIE,IAHA,IAAI8K,EAAI,EACJpC,EAAQ,GAELoC,EAAIH,EAASG,IAClBpC,EAAMoC,GAAK3D,EAAOqD,EAAKM,IAAIxC,GAI7BI,EAAMoC,GAAK9K,EACXyK,EAAGM,MAAM,KAAMrC,GAErB,CACF,EAMArF,EAAU1E,UAAUwP,cAAgB,SAAUtJ,GAE5C,IAAI2D,EAAUnK,KAAKiF,QAAQuB,GACvBuJ,EAAgBhM,IAEpB,IAAKoG,EACH,OAAO4F,EAIT,IAKIC,EALAC,EAAUjQ,KAAK4G,QAIfsJ,GAAUlQ,KAAK6F,SAGnB,GAAIqK,EACF,OAAOlQ,KAAKkF,WAAWsB,GAAKnC,QAK9B,GAFA2L,EAAYhQ,KAAKmF,QAAQqB,GAErBwJ,EACF,OAAOA,EAAU3L,QAGnB2L,EAAYD,EAIZ,IAHA,IAAI9H,EAAM+H,EAAU,GAChB9H,EAAM8H,EAAU,GAEXrO,EAAI,EAAGA,EAAIsO,EAAStO,IAAK,CAChC,IAAIsI,EAASjK,KAAK8F,YAAYnE,GAC1B0I,EAAQF,EAAQF,GACpBI,EAAQpC,IAAQA,EAAMoC,GACtBA,EAAQnC,IAAQA,EAAMmC,EACxB,CAIA,OAFA2F,EAAY,CAAC/H,EAAKC,GAClBlI,KAAKmF,QAAQqB,GAAOwJ,EACbA,CACT,EAMAhL,EAAU1E,UAAU6P,eAAiB,SAAUjH,GAC7C,IAAIe,EAASjK,KAAK8F,YAAYoD,GAE9B,GAAKlJ,KAAK4F,UAAU8C,WAUlB,OAAO1I,KAAK4F,UAAU6D,QAAQQ,GAN9B,IAHA,IAAIpC,EAAM,GACNiB,EAAS9I,KAAKiF,QAETtD,EAAI,EAAGA,EAAImH,EAAOxJ,OAAQqC,IACjCkG,EAAI5E,KAAK6F,EAAOnH,GAAGsI,IAGrB,OAAOpC,CAIX,EAQA7C,EAAU1E,UAAU+L,MAAQ,SAAU+D,EAAYC,GAChD,IAAI9C,EAAS,IAAIvI,EACb8D,EAAS9I,KAAKiF,QACdqL,EAAgBF,IAAcG,EAAAA,EAAAA,QAAOH,GAAY,SAAUI,EAAKhM,GAElE,OADAgM,EAAIhM,IAAU,EACPgM,CACT,GAAG,CAAC,GAEJ,GAAIF,EACF,IAAK,IAAI3O,EAAI,EAAGA,EAAImH,EAAOxJ,OAAQqC,IAEjC4L,EAAOtI,QAAQtD,GAAM2O,EAAc3O,GAAiBsC,EAAW6E,EAAOnH,IAA9BmH,EAAOnH,QAGjD4L,EAAOtI,QAAU6D,EAWnB,OARA9I,KAAKyQ,iBAAiBlD,GAEjB8C,IACH9C,EAAO1H,SAAW7F,KAAK0Q,iBAGzBnD,EAAOZ,mBAEAY,CACT,EAEAvI,EAAU1E,UAAUmQ,iBAAmB,SAAUlD,GAC/CA,EAAOnI,OAASpF,KAAKoF,OACrBmI,EAAOlI,UAAYrF,KAAKqF,UACxBkI,EAAO3H,UAAY5F,KAAK4F,UACxB2H,EAAOhH,YAAcvG,KAAKuG,YAC1BgH,EAAOpI,SAAUkH,EAAAA,EAAAA,OAAMrM,KAAKmF,SAC5BoI,EAAOrI,YAAamH,EAAAA,EAAAA,OAAMrM,KAAKkF,WACjC,EAEAF,EAAU1E,UAAUoQ,cAAgB,WAClC,GAAI1Q,KAAK6F,SAAU,CACjB,IAAI1B,EAAOnE,KAAK6F,SAASzB,YACrB2G,OAAU,EAEd,GAAI5G,IAAS3C,MAAO,CAClB,IAAIwK,EAAYhM,KAAK6F,SAASvG,OAC9ByL,EAAU,IAAI5G,EAAK6H,GAEnB,IAAK,IAAIrK,EAAI,EAAGA,EAAIqK,EAAWrK,IAC7BoJ,EAAQpJ,GAAK3B,KAAK6F,SAASlE,EAE/B,MACEoJ,EAAU,IAAI5G,EAAKnE,KAAK6F,UAG1B,OAAOkF,CACT,CAEA,OAAO,IACT,EAEA/F,EAAU1E,UAAUyF,mBAAqB,SAAUmD,GACjD,OAAOA,CACT,EAEAlE,EAAU1E,UAAUgP,WAAa,SAAUpG,GACzC,OAAIA,EAAMlJ,KAAKoF,QAAU8D,GAAO,EACvBlJ,KAAK6F,SAASqD,IAGf,CACV,EAEAlE,EAAU1E,UAAUqM,iBAAmB,WACrC3M,KAAK8F,YAAc9F,KAAK6F,SAAW7F,KAAKsP,WAAatP,KAAK+F,kBAC5D,EAEAf,EAAU2L,cAAgB,WACxB,SAASC,EAAkBpH,EAAU9C,EAAUgF,EAAWpD,GACxD,OAAOuI,EAAAA,EAAAA,IAAerH,EAASlB,GAAWtI,KAAKuG,YAAY+B,GAC7D,CAEApF,EAAyB,CACvBkG,UAAWwH,EACXE,WAAY,SAAUtH,EAAU9C,EAAUgF,EAAWpD,GACnD,OAAOuI,EAAAA,EAAAA,IAAerH,EAAS9C,GAAW1G,KAAKuG,YAAY+B,GAC7D,EACAyI,aAAcH,EACdI,SAAU,SAAUxH,EAAU9C,EAAUgF,EAAWpD,GAKjD,IAAI+B,EAAQb,IAA+B,MAAlBA,EAASa,MAAgBb,EAAWA,EAASa,OACtE,OAAOwG,EAAAA,EAAAA,IAAexG,aAAiB7I,MAAQ6I,EAAM/B,GACnD+B,EAAOrK,KAAKuG,YAAY+B,GAC5B,EACA2I,WAAY,SAAUzH,EAAU9C,EAAUgF,EAAWpD,GACnD,OAAOkB,EAASlB,EAClB,EAEJ,CAxB0B,GA0BnBtD,CACT,CArkCA,GAukCA,S,gDC/oCA,SAASkM,EAAgBC,GACvB,MAAO,OAASA,CAClB,CAEA,IAAIC,EAEJ,WACE,SAASA,EAAMC,GACbrR,KAAKyG,KAAO,QACZzG,KAAKsR,MAAQ,GACbtR,KAAKuR,MAAQ,GACbvR,KAAKwR,UAAY,CAAC,EAMlBxR,KAAKyR,UAAY,CAAC,EAClBzR,KAAK0R,UAAYL,IAAY,CAC/B,CAiRA,OA3QAD,EAAM9Q,UAAUqR,WAAa,WAC3B,OAAO3R,KAAK0R,SACd,EAOAN,EAAM9Q,UAAUsR,QAAU,SAAUT,EAAIzF,GACtCyF,EAAW,MAANA,EAAa,GAAKzF,EAAY,GAAKyF,EACxC,IAAIU,EAAW7R,KAAKwR,UAEpB,IAAIK,EAASX,EAAgBC,IAA7B,CAQA,IAAIW,EAAO,IAAIC,EAAUZ,EAAIzF,GAI7B,OAHAoG,EAAKE,UAAYhS,KACjBA,KAAKsR,MAAMrO,KAAK6O,GAChBD,EAASX,EAAgBC,IAAOW,EACzBA,CANP,CAOF,EAOAV,EAAM9Q,UAAU2R,eAAiB,SAAUvG,GACzC,IAAIzB,EAASjK,KAAKwI,KAAK1C,YAAY4F,GACnC,OAAO1L,KAAKsR,MAAMrH,EACpB,EAOAmH,EAAM9Q,UAAU4R,YAAc,SAAUf,GACtC,OAAOnR,KAAKwR,UAAUN,EAAgBC,GACxC,EAOAC,EAAM9Q,UAAU6R,QAAU,SAAUC,EAAIC,EAAI3G,GAC1C,IAAImG,EAAW7R,KAAKwR,UAChBc,EAAWtS,KAAKyR,UAkBpB,GAhBIc,EAAAA,SAAgBH,KAClBA,EAAKpS,KAAKsR,MAAMc,IAGdG,EAAAA,SAAgBF,KAClBA,EAAKrS,KAAKsR,MAAMe,IAGZD,aAAcL,IAClBK,EAAKP,EAASX,EAAgBkB,KAG1BC,aAAcN,IAClBM,EAAKR,EAASX,EAAgBmB,KAG3BD,GAAOC,EAAZ,CAIA,IAAItP,EAAMqP,EAAGjB,GAAK,IAAMkB,EAAGlB,GACvBqB,EAAO,IAAIC,EAAUL,EAAIC,EAAI3G,GAgBjC,OAfA8G,EAAKR,UAAYhS,KAEbA,KAAK0R,YACPU,EAAGM,SAASzP,KAAKuP,GACjBH,EAAGM,QAAQ1P,KAAKuP,IAGlBJ,EAAGb,MAAMtO,KAAKuP,GAEVJ,IAAOC,GACTA,EAAGd,MAAMtO,KAAKuP,GAGhBxS,KAAKuR,MAAMtO,KAAKuP,GAChBF,EAASvP,GAAOyP,EACTA,CAnBP,CAoBF,EAOApB,EAAM9Q,UAAUsS,eAAiB,SAAUlH,GACzC,IAAIzB,EAASjK,KAAK6S,SAAS/M,YAAY4F,GACvC,OAAO1L,KAAKuR,MAAMtH,EACpB,EAOAmH,EAAM9Q,UAAUwS,QAAU,SAAUV,EAAIC,GAClCD,aAAcL,IAChBK,EAAKA,EAAGjB,IAGNkB,aAAcN,IAChBM,EAAKA,EAAGlB,IAGV,IAAImB,EAAWtS,KAAKyR,UAEpB,OAAIzR,KAAK0R,UACAY,EAASF,EAAK,IAAMC,GAEpBC,EAASF,EAAK,IAAMC,IAAOC,EAASD,EAAK,IAAMD,EAE1D,EAOAhB,EAAM9Q,UAAUyS,SAAW,SAAU3G,EAAItM,GAIvC,IAHA,IAAIwR,EAAQtR,KAAKsR,MACb3J,EAAM2J,EAAMhS,OAEPqC,EAAI,EAAGA,EAAIgG,EAAKhG,IACnB2P,EAAM3P,GAAG+J,WAAa,GACxBU,EAAG/C,KAAKvJ,EAASwR,EAAM3P,GAAIA,EAGjC,EAOAyP,EAAM9Q,UAAU0S,SAAW,SAAU5G,EAAItM,GAIvC,IAHA,IAAIyR,EAAQvR,KAAKuR,MACb5J,EAAM4J,EAAMjS,OAEPqC,EAAI,EAAGA,EAAIgG,EAAKhG,IACnB4P,EAAM5P,GAAG+J,WAAa,GAAK6F,EAAM5P,GAAGsR,MAAMvH,WAAa,GAAK6F,EAAM5P,GAAGuR,MAAMxH,WAAa,GAC1FU,EAAG/C,KAAKvJ,EAASyR,EAAM5P,GAAIA,EAGjC,EAQAyP,EAAM9Q,UAAU6S,qBAAuB,SAAU/G,EAAIgH,EAAWC,EAAWvT,GAKzE,GAJMsT,aAAqBrB,IACzBqB,EAAYpT,KAAKwR,UAAUN,EAAgBkC,KAGxCA,EAAL,CAMA,IAFA,IAAIE,EAAyB,QAAdD,EAAsB,WAA2B,OAAdA,EAAqB,UAAY,QAE1E1R,EAAI,EAAGA,EAAI3B,KAAKsR,MAAMhS,OAAQqC,IACrC3B,KAAKsR,MAAM3P,GAAG4R,WAAY,EAG5B,IAAInH,EAAG/C,KAAKvJ,EAASsT,EAAW,MAAhC,CAIA,IAAII,EAAQ,CAACJ,GAEb,MAAOI,EAAMlU,OACX,KAAImU,EAAcD,EAAMxR,QACpBuP,EAAQkC,EAAYH,GAExB,IAAS3R,EAAI,EAAGA,EAAI4P,EAAMjS,OAAQqC,IAAK,CACrC,IAAI+R,EAAInC,EAAM5P,GACVgS,EAAYD,EAAET,QAAUQ,EAAcC,EAAER,MAAQQ,EAAET,MAEtD,IAAKU,EAAUJ,UAAW,CACxB,GAAInH,EAAG/C,KAAKvJ,EAAS6T,EAAWF,GAE9B,OAGFD,EAAMvQ,KAAK0Q,GACXA,EAAUJ,WAAY,CACxB,CACF,CAhB+B,CALjC,CAVA,CAiCF,EASAnC,EAAM9Q,UAAUI,OAAS,WAMvB,IALA,IAAI8H,EAAOxI,KAAKwI,KACZqK,EAAW7S,KAAK6S,SAChBvB,EAAQtR,KAAKsR,MACbC,EAAQvR,KAAKuR,MAER5P,EAAI,EAAGgG,EAAM2J,EAAMhS,OAAQqC,EAAIgG,EAAKhG,IAC3C2P,EAAM3P,GAAG+J,WAAa,EAGxB,IAAS/J,EAAI,EAAGgG,EAAMa,EAAK5B,QAASjF,EAAIgG,EAAKhG,IAC3C2P,EAAM9I,EAAK1C,YAAYnE,IAAI+J,UAAY/J,EAGzCkR,EAASe,YAAW,SAAU1K,GAC5B,IAAIsJ,EAAOjB,EAAMsB,EAAS/M,YAAYoD,IACtC,OAAOsJ,EAAKS,MAAMvH,WAAa,GAAK8G,EAAKU,MAAMxH,WAAa,CAC9D,IAEA,IAAS/J,EAAI,EAAGgG,EAAM4J,EAAMjS,OAAQqC,EAAIgG,EAAKhG,IAC3C4P,EAAM5P,GAAG+J,WAAa,EAGxB,IAAS/J,EAAI,EAAGgG,EAAMkL,EAASjM,QAASjF,EAAIgG,EAAKhG,IAC/C4P,EAAMsB,EAAS/M,YAAYnE,IAAI+J,UAAY/J,CAE/C,EAOAyP,EAAM9Q,UAAU+L,MAAQ,WAKtB,IAJA,IAAIwH,EAAQ,IAAIzC,EAAMpR,KAAK0R,WACvBJ,EAAQtR,KAAKsR,MACbC,EAAQvR,KAAKuR,MAER5P,EAAI,EAAGA,EAAI2P,EAAMhS,OAAQqC,IAChCkS,EAAMjC,QAAQN,EAAM3P,GAAGwP,GAAIG,EAAM3P,GAAG+J,WAGtC,IAAS/J,EAAI,EAAGA,EAAI4P,EAAMjS,OAAQqC,IAAK,CACrC,IAAI+R,EAAInC,EAAM5P,GACdkS,EAAM1B,QAAQuB,EAAET,MAAM9B,GAAIuC,EAAER,MAAM/B,GAAIuC,EAAEhI,UAC1C,CAEA,OAAOmI,CACT,EAGOzC,CACT,CA/RA,GAiSIW,EAEJ,WACE,SAASA,EAAUZ,EAAIzF,GACrB1L,KAAK2S,QAAU,GACf3S,KAAK0S,SAAW,GAChB1S,KAAKuR,MAAQ,GACbvR,KAAK0L,WAAa,EAClB1L,KAAKmR,GAAW,MAANA,EAAa,GAAKA,EAC5BnR,KAAK0L,UAAyB,MAAbA,GAAqB,EAAIA,CAC5C,CAwDA,OAlDAqG,EAAUzR,UAAUwT,OAAS,WAC3B,OAAO9T,KAAKuR,MAAMjS,MACpB,EAMAyS,EAAUzR,UAAUyT,SAAW,WAC7B,OAAO/T,KAAK2S,QAAQrT,MACtB,EAMAyS,EAAUzR,UAAU0T,UAAY,WAC9B,OAAOhU,KAAK0S,SAASpT,MACvB,EAEAyS,EAAUzR,UAAU2T,SAAW,SAAUC,GACvC,KAAIlU,KAAK0L,UAAY,GAArB,CAIA,IAAImI,EAAQ7T,KAAKgS,UACbmC,EAAYN,EAAMrL,KAAK4L,aAAapU,KAAK0L,WAC7C,OAAOyI,EAAUF,SAASC,EAJ1B,CAKF,EAEAnC,EAAUzR,UAAU+T,uBAAyB,WAM3C,IALA,IAAIC,EAAc,CAChB9B,KAAM,GACNV,KAAM,IAGCnQ,EAAI,EAAGA,EAAI3B,KAAKuR,MAAMjS,OAAQqC,IAAK,CAC1C,IAAI4S,EAAevU,KAAKuR,MAAM5P,GAE1B4S,EAAa7I,UAAY,IAI7B4I,EAAY9B,KAAKvP,KAAKsR,EAAa7I,WACnC4I,EAAYxC,KAAK7O,KAAKsR,EAAatB,MAAMvH,UAAW6I,EAAarB,MAAMxH,WACzE,CAEA,OAAO4I,CACT,EAEOvC,CACT,CAjEA,GAmEIU,EAEJ,WACE,SAASA,EAAUL,EAAIC,EAAI3G,GACzB1L,KAAK0L,WAAa,EAClB1L,KAAKiT,MAAQb,EACbpS,KAAKkT,MAAQb,EACbrS,KAAK0L,UAAyB,MAAbA,GAAqB,EAAIA,CAC5C,CAoBA,OAjBA+G,EAAUnS,UAAU2T,SAAW,SAAUC,GACvC,KAAIlU,KAAK0L,UAAY,GAArB,CAIA,IAAImI,EAAQ7T,KAAKgS,UACbmC,EAAYN,EAAMhB,SAASuB,aAAapU,KAAK0L,WACjD,OAAOyI,EAAUF,SAASC,EAJ1B,CAKF,EAEAzB,EAAUnS,UAAU+T,uBAAyB,WAC3C,MAAO,CACL7B,KAAM,CAACxS,KAAK0L,WACZoG,KAAM,CAAC9R,KAAKiT,MAAMvH,UAAW1L,KAAKkT,MAAMxH,WAE5C,EAEO+G,CACT,CA3BA,GA6BA,SAAS+B,EAA0BC,EAAUC,GAC3C,MAAO,CAILC,SAAU,SAAUnF,GAClB,IAAIhH,EAAOxI,KAAKyU,GAAUC,GAC1B,OAAOlM,EAAKoM,WAAWzN,IAAIqB,EAAKqM,kBAAkBrF,GAAa,SAAUxP,KAAK0L,UAChF,EAEAoJ,UAAW,SAAU/R,EAAKsH,GACxBrK,KAAK0L,WAAa,GAAK1L,KAAKyU,GAAUC,GAAUK,cAAc/U,KAAK0L,UAAW3I,EAAKsH,EACrF,EACA2K,UAAW,SAAUjS,GACnB,OAAO/C,KAAKyU,GAAUC,GAAUO,cAAcjV,KAAK0L,UAAW3I,EAChE,EACAmS,UAAW,SAAUC,EAAQC,GAC3BpV,KAAK0L,WAAa,GAAK1L,KAAKyU,GAAUC,GAAUW,cAAcrV,KAAK0L,UAAWyJ,EAAQC,EACxF,EACAE,UAAW,WACT,OAAOtV,KAAKyU,GAAUC,GAAUa,cAAcvV,KAAK0L,UACrD,EACA8J,aAAc,WACZ,OAAOxV,KAAKyU,GAAUC,GAAUe,iBAAiBzV,KAAK0L,UACxD,EACA5F,YAAa,WACX,OAAO9F,KAAKyU,GAAUC,GAAU5O,YAAY9F,KAAK0L,UACnD,EAEJ,CAKA6G,EAAAA,MAAaR,EAAWyC,EAA0B,YAAa,SAC/DjC,EAAAA,MAAaE,EAAW+B,EAA0B,YAAa,aAC/D,S,uCChbIkB,EAAU,EAEVC,EAEJ,WACE,SAASA,EAAYC,GACnB5V,KAAK6V,WAAaD,EAAIC,YAAc,GACpC7V,KAAK8V,aAAeF,EAAIG,YACxB/V,KAAKgW,eAAiBJ,EAAIK,cAC1BjW,KAAKkW,MAAQR,CACf,CA2EA,OAzEAC,EAAYQ,kBAAoB,SAAUC,GACxC,IAAIC,EAASD,EAAUC,OACnB7N,EAAO6N,EAAO7N,KACdqN,EAAarN,IAAQ7F,EAAAA,EAAAA,KAAI6F,EAAM8N,GACnC,OAAO,IAAIX,EAAY,CACrBE,WAAYA,EACZE,aAAcF,EAEdI,eAAuC,IAAxBI,EAAOE,cAE1B,EAIAZ,EAAYrV,UAAUkW,WAAa,SAAUC,GAE3C,OAAOzW,KAAK0W,kBAAkBvP,IAAIsP,EACpC,EAMAd,EAAYrV,UAAUwH,gBAAkB,SAAU2O,GAChD,IAAIE,EACAZ,EAAc/V,KAAK8V,aAMvB,KAAKc,EAAAA,EAAAA,UAASH,KAAcV,EAC1B,OAAOU,EAWT,GAAIV,IAAgB/V,KAAKgW,eAGvB,OAFAW,EAAQ3W,KAAK6V,WAAWvW,OACxBU,KAAK6V,WAAWc,GAASF,EAClBE,EAGT,IAAIhU,EAAM3C,KAAK0W,kBAgBf,OAbAC,EAAQhU,EAAIwE,IAAIsP,GAEH,MAATE,IACEZ,GACFY,EAAQ3W,KAAK6V,WAAWvW,OACxBU,KAAK6V,WAAWc,GAASF,EAEzB9T,EAAIyE,IAAIqP,EAAUE,IAElBA,EAAQ/M,KAIL+M,CACT,EAGAhB,EAAYrV,UAAUoW,gBAAkB,WACtC,OAAO1W,KAAK6W,OAAS7W,KAAK6W,MAAOtR,EAAAA,EAAAA,eAAcvF,KAAK6V,YACtD,EAEOF,CACT,CAlFA,GAoFA,SAASW,EAAQ9F,GACf,OAAIsG,EAAAA,EAAAA,UAAStG,IAAqB,MAAbA,EAAInG,MAChBmG,EAAInG,MAEJmG,EAAM,EAEjB,CAEA,Q,2GCtEIuG,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,E,oIAnBAP,EAAWvE,EAAAA,SACX5P,EAAM4P,EAAAA,IACN/O,EAAuC,qBAAfC,WAA6BjC,MAAQiC,WAG7D6T,EAAY,QACZC,GAAmB,EAEnBC,EAA0B,CAAC,gBAAiB,YAAa,UAAW,sBAAuB,cAAe,aAAc,WAAY,kBAAmB,cAAe,YAAa,oBACnLC,EAAmB,CAAC,sBAYpBC,EAEJ,WAME,SAASA,EAAWC,EAAiBC,GAgCnC,IAAI3Q,EA/BJjH,KAAKyG,KAAO,OACZzG,KAAK6X,aAAc,EACnB7X,KAAK8X,UAAY,GACjB9X,KAAK+X,QAAU,GAKf/X,KAAKgY,QAAU,CAAC,EAEhBhY,KAAKiY,QAAU,CAAC,EAEhBjY,KAAKkY,aAAe,GAEpBlY,KAAKmY,aAAe,GAEpBnY,KAAKoY,YAAc,GAEnBpY,KAAKqY,mBAAqB,CAAC,EAC3BrY,KAAKsY,iBAAmB,CAAC,EAKzBtY,KAAKuY,eAAgB,EAGrBvY,KAAKwY,qBAAuB,CAAC,eAAgB,aAAc,iBAAkB,OAE7ExY,KAAKyY,kBAAoB,CAAC,aAAc,eACxCzY,KAAK0Y,mBAAqB,CAAC,aAAc,kBAEzC,IAAIC,GAAoB,GAEpBC,EAAAA,EAAAA,IAAmBjB,IACrB1Q,EAAa0Q,EAAgB1Q,WAC7BjH,KAAK6X,YAAcF,EAAgBkB,qBACnC7Y,KAAK8Y,QAAUnB,IAEfgB,GAAoB,EACpB1R,EAAa0Q,GAGf1Q,EAAaA,GAAc,CAAC,IAAK,KAOjC,IANA,IAAI8R,EAAiB,CAAC,EAClBC,EAAiB,GACjBC,EAAqB,CAAC,EACtBC,GAAc,EACdC,EAAW,CAAC,EAEPxX,EAAI,EAAGA,EAAIsF,EAAW3H,OAAQqC,IAAK,CAE1C,IAAIyX,EAAenS,EAAWtF,GAC1B0X,EAAgB9G,EAAAA,SAAgB6G,GAAgB,IAAIE,EAAAA,EAAsB,CAC5EC,KAAMH,IACDA,aAAwBE,EAAAA,EAAmEF,EAA1C,IAAIE,EAAAA,EAAsBF,GAC9EI,EAAgBH,EAAcE,KAClCF,EAAc5S,KAAO4S,EAAc5S,MAAQ,QAEtC4S,EAAcI,WACjBJ,EAAcI,SAAWD,EACzBH,EAAcK,cAAgB,GAGhC,IAAIC,EAAYN,EAAcM,UAAYN,EAAcM,WAAa,CAAC,EACtEX,EAAe/V,KAAKuW,GACpBT,EAAeS,GAAiBH,EAED,MAA3BF,EAASK,KACXN,GAAc,GAGZG,EAAcO,wBAChBX,EAAmBO,GAAiB,IAGX,IAAvBG,EAAUE,WACZ7Z,KAAK8Z,YAAcnY,GAGI,IAArBgY,EAAUI,SACZ/Z,KAAKga,UAAYrY,GAOfgX,IACFU,EAAcY,cAAgBtY,EAElC,CAUA,GARA3B,KAAKiH,WAAa+R,EAClBhZ,KAAKka,UAAYnB,EAEjB/Y,KAAKma,sBAAsBjB,GAE3BlZ,KAAK4X,UAAYA,EACjB5X,KAAKoa,oBAAsBnB,EAEvBjZ,KAAK6X,YAAa,CACpB,IAAIwC,EAAiBra,KAAKsa,cAAgB/H,EAAAA,gBAC1CA,EAAAA,KAAYyG,GAAgB,SAAUjS,GACpCsT,EAAejT,IAAI2R,EAAehS,GAASkT,cAAelT,EAC5D,GACF,CACF,CAi/BA,OA79BA2Q,EAAWpX,UAAUia,aAAe,SAAU/T,GAC5C,IAAIhC,EAASxE,KAAKwa,mBAAmBhU,GAErC,GAAc,MAAVhC,EACF,OAAOgC,EAKT,GAFAhC,EAASgC,GAEJxG,KAAK6X,YACR,OAAO7X,KAAKiH,WAAWzC,GAKzB,IAAIuC,EAAU/G,KAAKsa,cAAcnT,IAAI3C,GAErC,GAAe,MAAXuC,EACF,OAAOA,EAGT,IAAI0T,EAAeza,KAAK8Y,QAAQ4B,mBAAmBlW,GAEnD,OAAIiW,EACKA,EAAalB,UADtB,CAGF,EAOA7B,EAAWpX,UAAUuU,kBAAoB,SAAUrO,GACjD,IAAIhC,EAASxE,KAAKwa,mBAAmBhU,GAErC,GAAc,MAAVhC,EACF,OAAOA,EAGT,GAAW,MAAPgC,EACF,OAAQ,EAGV,IAAI4B,EAAUpI,KAAK2a,YAAYnU,GAE/B,OAAO4B,EAAUA,EAAQ6R,cAAgBja,KAAK6X,YAAc7X,KAAK8Y,QAAQ8B,wBAAwBpU,IAAQ,CAC3G,EAsBAkR,EAAWpX,UAAUka,mBAAqB,SAAUhU,GAClD,GAAI+L,EAAAA,SAAgB/L,IACV,MAAPA,IAAgBuB,MAAMvB,KAASxG,KAAK2a,YAAYnU,MAAUxG,KAAK6X,aAAe7X,KAAK8Y,QAAQ8B,wBAAwBpU,GAAO,GAC3H,OAAQA,CAEZ,EAEAkR,EAAWpX,UAAUua,kBAAoB,SAAUrU,GACjD,IAAIhC,EAASxE,KAAK6U,kBAAkBrO,GAQpC,OAAOhC,CACT,EASAkT,EAAWpX,UAAUwa,iBAAmB,SAAUtU,GAEhD,OAAOxG,KAAK2a,YAAY3a,KAAKua,aAAa/T,GAC5C,EAEAkR,EAAWpX,UAAU6Z,sBAAwB,SAAUjB,GACrD,IAAIH,EAAiB/Y,KAAKka,UAC1Bla,KAAK2a,YAAczB,EAAc,SAAUnS,GACzC,OAAOgS,EAAegC,eAAehU,GAAWgS,EAAehS,QAAWiU,CAC5E,EAAI,SAAUjU,GACZ,OAAOgS,EAAehS,EACxB,CACF,EAMA2Q,EAAWpX,UAAU2a,qBAAuB,WAC1C,OAAOjb,KAAKkb,YAAYC,gBAAgB9W,OAC1C,EAEAqT,EAAWpX,UAAU8a,aAAe,SAAU3B,EAAUvQ,GACtD,IAAImS,EAAoBrb,KAAKkb,YAE7B,GAAW,MAAPhS,EACF,OAAOmS,EAAkBC,uBAAuB7B,GAGlD,IAAItN,EAAOkP,EAAkBE,OAAO9B,GACpC,OAAOtN,EAAOA,EAAKjD,GAAO,IAC5B,EAEAwO,EAAWpX,UAAUkb,iBAAmB,SAAU/B,GAChD,IAAI4B,EAAoBrb,KAAKkb,YACzB/O,EAAOkP,EAAkBE,OAAO9B,GACpC,OAAQtN,GAAQ,IAAI9H,OACtB,EAEAqT,EAAWpX,UAAUsU,SAAW,WAC9B,OAAO5U,KAAKyb,MACd,EAYA/D,EAAWpX,UAAUkF,SAAW,SAAUgD,EAAMkT,EAAU/V,GACxD,IAEIpB,EAFAoX,EAAQ3b,KAQZ,GAJIwI,aAAgBxD,EAAAA,KAClBT,EAAQiE,IAGLjE,EAAO,CACV,IAAI0C,EAAajH,KAAKiH,WAClBxB,GAAWmW,EAAAA,EAAAA,IAAiBpT,IAAS+J,EAAAA,YAAmB/J,GAAQ,IAAIqT,EAAAA,GAAoBrT,EAAMvB,EAAW3H,QAAUkJ,EACvHjE,EAAQ,IAAIS,EAAAA,GACZ,IAAI+T,EAAiBpW,EAAIsE,GAAY,SAAUF,GAC7C,MAAO,CACLN,KAAMkV,EAAMzB,UAAUnT,GAASN,KAC/BC,SAAUK,EAEd,IACAxC,EAAMiB,SAASC,EAAUsT,EAAgBpT,EAC3C,CAEA3F,KAAKyb,OAASlX,EAEdvE,KAAK8X,WAAa4D,GAAY,IAAIrX,QAClCrE,KAAK+X,QAAU,GACf/X,KAAK8b,iBAAmB,CAAC,EAEzB9b,KAAK+b,QAAQ,EAAGxX,EAAMqC,SAItB5G,KAAKkb,aAAcc,EAAAA,EAAAA,GAAoBhc,KAAMA,KAAK8Y,SAClD9Y,KAAKic,WAAajc,KAAKkb,YAAYe,UACrC,EAMAvE,EAAWpX,UAAUiI,WAAa,SAAUC,GAC1C,IAAIqE,EAAQ7M,KAAKyb,OAAOlT,WAAWC,GAEnCxI,KAAK+b,QAAQlP,EAAM,GAAIA,EAAM,GAC/B,EAkBA6K,EAAWpX,UAAUqI,aAAe,SAAUC,EAAQsT,GACpD,IAAIC,EAAKnc,KAAKyb,OAAO9S,aAAaC,EAAQsT,EAAM5c,QAC5CmJ,EAAQ0T,EAAG1T,MACX/D,EAAMyX,EAAGzX,IAET0X,EAAuBpc,KAAKqc,wBAIhC,GAFArc,KAAKsc,qBAEDJ,EACF,IAAK,IAAIhT,EAAMT,EAAOS,EAAMxE,EAAKwE,IAAO,CACtC,IAAIC,EAAYD,EAAMT,EACtBzI,KAAK8X,UAAU5O,GAAOgT,EAAM/S,GAExBiT,GACF/E,EAAerX,KAAMkJ,EAEzB,CAEJ,EAEAwO,EAAWpX,UAAUgc,mBAAqB,WAIxC,IAHA,IAAI/X,EAAQvE,KAAKyb,OACbxU,EAAajH,KAAKiH,WAEbtF,EAAI,EAAGA,EAAIsF,EAAW3H,OAAQqC,IAAK,CAC1C,IAAIyG,EAAUpI,KAAKka,UAAUjT,EAAWtF,IAEpCyG,EAAQd,aACV/C,EAAM8C,mBAAmBe,EAAQ6R,cAAe7R,EAAQd,YAE5D,CACF,EAEAoQ,EAAWpX,UAAU+b,sBAAwB,WAC3C,IAAI5W,EAAWzF,KAAKyb,OAAO5U,cAE3B,OAAyB,MAAlB7G,KAAKga,WAAqBvU,EAASQ,YAAYG,eAAiBmW,EAAAA,KAA8B9W,EAAS8D,WAChH,EAEAmO,EAAWpX,UAAUyb,QAAU,SAAUtT,EAAO/D,GAC9C,KAAI+D,GAAS/D,GAAb,CAIA,IAAIH,EAAQvE,KAAKyb,OACbhW,EAAWlB,EAAMsC,cAErB7G,KAAKsc,qBAEL,IAAIZ,EAAW1b,KAAK8X,UAChB0E,EAASxc,KAAK+X,QACd3R,EAAeX,EAASQ,YAAYG,aACpCqW,EAAmBrW,IAAiBsW,EAAAA,GASxC,GAAID,IAAqBhX,EAASkX,KAGhC,IAFA,IAAIC,EAAiB,GAEZ1T,EAAMT,EAAOS,EAAMxE,EAAKwE,IAAO,CAEtC,IAAIM,EAAW/D,EAASgE,QAAQP,EAAK0T,GAMrC,IAJK5c,KAAKuY,gBAAiBsE,EAAAA,EAAAA,IAAiBrT,KAC1CxJ,KAAKuY,eAAgB,GAGnB/O,EAAU,CACZ,IAAIqQ,EAAWrQ,EAAS+P,KAEH,MAAjBmC,EAASxS,IAA4B,MAAZ2Q,IAC3B6B,EAASxS,IAAO4T,EAAAA,EAAAA,IAAoBjD,EAAU,OAGhD,IAAIE,EAASvQ,EAAS2H,GAEH,MAAfqL,EAAOtT,IAA0B,MAAV6Q,IACzByC,EAAOtT,IAAO4T,EAAAA,EAAAA,IAAoB/C,EAAQ,MAE9C,CACF,CAGF,GAAI/Z,KAAKqc,wBACP,IAASnT,EAAMT,EAAOS,EAAMxE,EAAKwE,IAC/BmO,EAAerX,KAAMkJ,GAIzB6N,EAAqB/W,KApDrB,CAqDF,EAiBA0X,EAAWpX,UAAUyc,qBAAuB,SAAUvW,GACpD,OAAOxG,KAAKqY,mBAAmB7R,IAAQxG,KAAKyb,OAAO3L,cAAc9P,KAAK6a,kBAAkBrU,GAC1F,EAOAkR,EAAWpX,UAAU0c,qBAAuB,SAAUC,EAAQzW,GAC5DA,EAAMxG,KAAKua,aAAa/T,GACxBxG,KAAKqY,mBAAmB7R,GAAOyW,EAAO5Y,OACxC,EAEAqT,EAAWpX,UAAU4c,mBAAqB,SAAUna,GAClD,OAAO/C,KAAKsY,iBAAiBvV,EAC/B,EAEA2U,EAAWpX,UAAU6c,mBAAqB,SAAUpa,EAAKsH,GACvDyM,EAAS/T,GAAOwP,EAAAA,OAAcvS,KAAKsY,iBAAkBvV,GAAO/C,KAAKsY,iBAAiBvV,GAAOsH,CAC3F,EASAqN,EAAWpX,UAAUgW,QAAU,SAAUpN,GACvC,IAAI4B,EAAW9K,KAAK8F,YAAYoD,GAC5BqQ,EAAOvZ,KAAK8X,UAAUhN,GAU1B,OARY,MAARyO,GAAoC,MAApBvZ,KAAK8Z,cACvBP,EAAOtC,EAAmBjX,KAAMA,KAAK8Z,YAAahP,IAGxC,MAARyO,IACFA,EAAO,IAGFA,CACT,EAEA7B,EAAWpX,UAAU8c,aAAe,SAAU5Y,EAAQ0E,GACpD,IAAImU,EAAUrd,KAAKyb,OAAOtU,IAAI3C,EAAQ0E,GAElC5B,EAActH,KAAKyb,OAAOtT,eAAe3D,GAE7C,OAAI8C,EACKA,EAAYuO,WAAWwH,GAGzBA,CACT,EASA3F,EAAWpX,UAAU0W,MAAQ,SAAU9N,GACrC,OAAO8N,EAAMhX,KAAMA,KAAK8F,YAAYoD,GACtC,EAEAwO,EAAWpX,UAAUsG,MAAQ,WAC3B,OAAO5G,KAAKyb,OAAO7U,OACrB,EAQA8Q,EAAWpX,UAAU6G,IAAM,SAAUX,EAAK0C,GACxC,IAAI3E,EAAQvE,KAAKyb,OACbrT,EAAUpI,KAAKka,UAAU1T,GAE7B,GAAI4B,EACF,OAAO7D,EAAM4C,IAAIiB,EAAQ6R,cAAe/Q,EAE5C,EAMAwO,EAAWpX,UAAU0J,cAAgB,SAAUxD,EAAKyD,GAClD,IAAI1F,EAAQvE,KAAKyb,OACbrT,EAAUpI,KAAKka,UAAU1T,GAE7B,GAAI4B,EACF,OAAO7D,EAAMyF,cAAc5B,EAAQ6R,cAAehQ,EAEtD,EAEAyN,EAAWpX,UAAUwL,WAAa,WAChC,OAAO9L,KAAKyb,OAAO3P,YACrB,EAEA4L,EAAWpX,UAAUwP,cAAgB,SAAUtJ,GAC7C,OAAOxG,KAAKyb,OAAO3L,cAAc9P,KAAK6a,kBAAkBrU,GAC1D,EAEAkR,EAAWpX,UAAU4J,OAAS,SAAU1D,GACtC,OAAOxG,KAAKyb,OAAOvR,OAAOlK,KAAK6a,kBAAkBrU,GACnD,EAEAkR,EAAWpX,UAAUgK,UAAY,SAAU9D,GACzC,OAAOxG,KAAKyb,OAAOnR,UAAUtK,KAAK6a,kBAAkBrU,GACtD,EAEAkR,EAAWpX,UAAUwJ,UAAY,SAAU7C,EAAYiC,GACrD,IAAIyS,EAAQ3b,KAERuE,EAAQvE,KAAKyb,OACjB,OAAOlJ,EAAAA,QAAetL,GAAc1C,EAAMuF,UAAUnH,EAAIsE,GAAY,SAAUT,GAC5E,OAAOmV,EAAMd,kBAAkBrU,EACjC,IAAI0C,GAAO3E,EAAMuF,UAAU7C,EAC7B,EAOAyQ,EAAWpX,UAAUgd,SAAW,SAAUpU,GAGxC,IAFA,IAAIqU,EAAwBvd,KAAKkb,YAAYqC,sBAEpC5b,EAAI,EAAGgG,EAAM4V,EAAsBje,OAAQqC,EAAIgG,EAAKhG,IAI3D,GAAIoG,MAAM/H,KAAKyb,OAAOtU,IAAIoW,EAAsB5b,GAAIuH,IAClD,OAAO,EAIX,OAAO,CACT,EAMAwO,EAAWpX,UAAUkd,YAAc,SAAUjE,GAC3C,IAAK,IAAI5X,EAAI,EAAGgG,EAAM3H,KAAKyb,OAAO7U,QAASjF,EAAIgG,EAAKhG,IAClD,GAAI3B,KAAKsW,QAAQ3U,KAAO4X,EACtB,OAAO5X,EAIX,OAAQ,CACV,EAEA+V,EAAWpX,UAAUwF,YAAc,SAAUoD,GAC3C,OAAOlJ,KAAKyb,OAAO3V,YAAYoD,EACjC,EAEAwO,EAAWpX,UAAUuK,gBAAkB,SAAUC,GAC/C,OAAO9K,KAAKyb,OAAO5Q,gBAAgBC,EACrC,EAUA4M,EAAWpX,UAAUmd,WAAa,SAAUjX,EAAK6D,GAC/C,IAAIqT,EAAkBlX,GAAOxG,KAAKoa,oBAAoB5T,GAQtD,IAAIsE,EAAW4S,EAAgBrT,GAE/B,OAAgB,MAAZS,GAAoB/C,MAAM+C,GACrByM,EAGFzM,CACT,EAWA4M,EAAWpX,UAAU8K,iBAAmB,SAAU5E,EAAK6D,EAAOgB,GAC5D,OAAOrL,KAAKyb,OAAOrQ,iBAAiBpL,KAAK6a,kBAAkBrU,GAAM6D,EAAOgB,EAC1E,EAEAqM,EAAWpX,UAAUkK,KAAO,SAAU2B,EAAMC,EAAIuR,GAG1CpL,EAAAA,WAAkBpG,KACpBwR,EAAMvR,EACNA,EAAKD,EACLA,EAAO,IAIT,IAAIyR,EAAOD,GAAO3d,KACd6d,EAAalb,EAAIuU,EAAoB/K,GAAOnM,KAAK6a,kBAAmB7a,MAExEA,KAAKyb,OAAOjR,KAAKqT,EAAYD,EAAOrL,EAAAA,KAAYnG,EAAIwR,GAAQxR,EAC9D,EAEAsL,EAAWpX,UAAUsT,WAAa,SAAUzH,EAAMC,EAAIuR,GAGhDpL,EAAAA,WAAkBpG,KACpBwR,EAAMvR,EACNA,EAAKD,EACLA,EAAO,IAIT,IAAIyR,EAAOD,GAAO3d,KACd6d,EAAalb,EAAIuU,EAAoB/K,GAAOnM,KAAK6a,kBAAmB7a,MAExE,OADAA,KAAKyb,OAASzb,KAAKyb,OAAOvP,OAAO2R,EAAYD,EAAOrL,EAAAA,KAAYnG,EAAIwR,GAAQxR,GACrEpM,IACT,EAOA0X,EAAWpX,UAAUsM,YAAc,SAAUC,GAG3C,IAAI8O,EAAQ3b,KAER8d,EAAa,CAAC,EACd3R,EAAOoG,EAAAA,KAAY1F,GACnBgR,EAAa,GAQjB,OAPAtL,EAAAA,KAAYpG,GAAM,SAAU3F,GAC1B,IAAIhC,EAASmX,EAAMd,kBAAkBrU,GAErCsX,EAAWtZ,GAAUqI,EAAMrG,GAC3BqX,EAAW5a,KAAKuB,EAClB,IACAxE,KAAKyb,OAASzb,KAAKyb,OAAO7O,YAAYkR,GAC/B9d,IACT,EAIA0X,EAAWpX,UAAUyd,SAAW,SAAU5R,EAAMC,EAAIuR,GAG9CpL,EAAAA,WAAkBpG,KACpBwR,EAAMvR,EACNA,EAAKD,EACLA,EAAO,IAITwR,EAAMA,GAAO3d,KACb,IAAIge,EAAS,GAIb,OAHAhe,KAAKwK,KAAK2B,GAAM,WACd6R,EAAO/a,KAAKmJ,GAAMA,EAAGM,MAAM1M,KAAMie,WACnC,GAAGN,GACIK,CACT,EAEAtG,EAAWpX,UAAUqC,IAAM,SAAUwJ,EAAMC,EAAIuR,EAAKO,GAGlD,IAAIN,EAAOD,GAAOO,GAAale,KAC3B6d,EAAalb,EAAIuU,EAAoB/K,GAAOnM,KAAK6a,kBAAmB7a,MACpEme,EAAO/G,EAAyBpX,MAEpC,OADAme,EAAK1C,OAASzb,KAAKyb,OAAO9Y,IAAIkb,EAAYD,EAAOrL,EAAAA,KAAYnG,EAAIwR,GAAQxR,GAClE+R,CACT,EAEAzG,EAAWpX,UAAUmN,OAAS,SAAUtB,EAAMC,EAAIuR,EAAKO,GACrD,IAGIN,EAAOD,GAAOO,GAAale,KAY/B,IAAI6d,EAAalb,EAAIuU,EAAoB/K,GAAOnM,KAAK6a,kBAAmB7a,MAKxEA,KAAKyb,OAAOhO,OAAOoQ,EAAYD,EAAOrL,EAAAA,KAAYnG,EAAIwR,GAAQxR,EAChE,EAOAsL,EAAWpX,UAAUiP,WAAa,SAAUC,EAAWvB,EAAMwB,EAAaC,GACxE,IAAIyO,EAAO/G,EAAyBpX,MAEpC,OADAme,EAAK1C,OAASzb,KAAKyb,OAAOlM,WAAWvP,KAAK6a,kBAAkBrL,GAAYvB,EAAMwB,EAAaC,GACpFyO,CACT,EAQAzG,EAAWpX,UAAUyN,eAAiB,SAAUC,EAAgBC,GAC9D,IAAIkQ,EAAO/G,EAAyBpX,MAEpC,OADAme,EAAK1C,OAASzb,KAAKyb,OAAO1N,eAAe/N,KAAK6a,kBAAkB7M,GAAiBC,GAC1EkQ,CACT,EAEAzG,EAAWpX,UAAU6P,eAAiB,SAAUjH,GAC9C,OAAOlJ,KAAKyb,OAAOtL,eAAejH,EACpC,EAOAwO,EAAWpX,UAAU8T,aAAe,SAAUlL,GAC5C,IAAI0O,EAAY5X,KAAK4X,UACjBpO,EAAWxJ,KAAKmQ,eAAejH,GACnC,OAAO,IAAIkV,EAAAA,EAAM5U,EAAUoO,EAAWA,GAAaA,EAAUyG,QAC/D,EAMA3G,EAAWpX,UAAUqL,KAAO,SAAU2S,GACpC,IAAIC,EAAWve,KACf,OAAO,IAAIP,EAAAA,EAAW6e,EAAYA,EAAU1J,WAAW9I,aAAe,GAAI9L,KAAK4U,WAAW9I,cAAc,SAAU5C,GAChH,OAAO8N,EAAMsH,EAAWpV,EAC1B,IAAG,SAAUA,GACX,OAAO8N,EAAMuH,EAAUrV,EACzB,GACF,EAMAwO,EAAWpX,UAAU0U,UAAY,SAAUjS,GACzC,IAAIyb,EAASxe,KAAKgY,QAClB,OAAOwG,GAAUA,EAAOzb,EAC1B,EAEA2U,EAAWpX,UAAUwU,UAAY,SAAU2J,EAAO5W,GAChD7H,KAAKgY,QAAUhY,KAAKgY,SAAW,CAAC,EAE5BlB,EAAS2H,GACXlM,EAAAA,OAAcvS,KAAKgY,QAASyG,GAE5Bze,KAAKgY,QAAQyG,GAAS5W,CAE1B,EAOA6P,EAAWpX,UAAU2U,cAAgB,SAAU/L,EAAKnG,GAClD,IAAI2b,EAAa1e,KAAKkY,aAAahP,GAC/BrB,EAAM6W,GAAcA,EAAW3b,GAEnC,OAAW,MAAP8E,EAEK7H,KAAKgV,UAAUjS,GAGjB8E,CACT,EAMA6P,EAAWpX,UAAUqe,cAAgB,WACnC,OAAO3e,KAAKkY,aAAa5Y,OAAS,CACpC,EAOAoY,EAAWpX,UAAUse,uBAAyB,SAAU1V,EAAKnG,GAC3D,IAAI8b,EAAc7e,KAAKkY,aACnBwG,EAAaG,EAAY3V,GAExBwV,IACHA,EAAaG,EAAY3V,GAAO,CAAC,GAGnC,IAAIrB,EAAM6W,EAAW3b,GAcrB,OAZW,MAAP8E,IACFA,EAAM7H,KAAKgV,UAAUjS,GAEjBwP,EAAAA,QAAe1K,GACjBA,EAAMA,EAAIxD,QACDyS,EAASjP,KAClBA,EAAM0K,EAAAA,OAAc,CAAC,EAAG1K,IAG1B6W,EAAW3b,GAAO8E,GAGbA,CACT,EAGA6P,EAAWpX,UAAUyU,cAAgB,SAAU7L,EAAKnG,EAAKsH,GACvD,IAAIqU,EAAa1e,KAAKkY,aAAahP,IAAQ,CAAC,EAC5ClJ,KAAKkY,aAAahP,GAAOwV,EAErB5H,EAAS/T,GACXwP,EAAAA,OAAcmM,EAAY3b,GAE1B2b,EAAW3b,GAAOsH,CAEtB,EAMAqN,EAAWpX,UAAUwe,eAAiB,WACpC9e,KAAKgY,QAAU,CAAC,EAChBhY,KAAKkY,aAAe,EACtB,EAEAR,EAAWpX,UAAU4U,UAAY,SAAUnS,EAAK8E,GAC9CiP,EAAS/T,GAAOwP,EAAAA,OAAcvS,KAAKiY,QAASlV,GAAO/C,KAAKiY,QAAQlV,GAAO8E,CACzE,EAMA6P,EAAWpX,UAAUgV,UAAY,SAAUvS,GACzC,OAAO/C,KAAKiY,QAAQlV,EACtB,EAMA2U,EAAWpX,UAAUiV,cAAgB,SAAUrM,GAC7C,OAAOlJ,KAAKmY,aAAajP,EAC3B,EAMAwO,EAAWpX,UAAU+U,cAAgB,SAAUnM,EAAKiM,EAAQC,GAC1DpV,KAAKmY,aAAajP,GAAOkM,EAAQ7C,EAAAA,OAAcvS,KAAKmY,aAAajP,IAAQ,CAAC,EAAGiM,GAAUA,CACzF,EAMAuC,EAAWpX,UAAUye,iBAAmB,WACtC/e,KAAKmY,aAAa7Y,OAAS,CAC7B,EAMAoY,EAAWpX,UAAU0e,iBAAmB,SAAU9V,EAAK+V,GACrD,IAAIC,EAAclf,KAAK4X,WAAa5X,KAAK4X,UAAUsH,aACnDC,EAAAA,EAAAA,GAAgBD,EAAalf,KAAKof,SAAUlW,EAAK+V,GACjDjf,KAAKoY,YAAYlP,GAAO+V,CAC1B,EAEAvH,EAAWpX,UAAUmV,iBAAmB,SAAUvM,GAChD,OAAOlJ,KAAKoY,YAAYlP,EAC1B,EAEAwO,EAAWpX,UAAU+e,kBAAoB,SAAUjT,EAAItM,GACrDyS,EAAAA,KAAYvS,KAAKoY,aAAa,SAAU6G,EAAI/V,GACtC+V,GACF7S,GAAMA,EAAG/C,KAAKvJ,EAASmf,EAAI/V,EAE/B,GACF,EAOAwO,EAAWpX,UAAUgf,aAAe,SAAUnB,GAO5C,OANKA,IACHA,EAAO,IAAIzG,EAAW1X,KAAK8Y,QAAU9Y,KAAK8Y,QAAUnW,EAAI3C,KAAKiH,WAAYjH,KAAK2a,YAAa3a,MAAOA,KAAK4X,YAGzGT,EAAmBgH,EAAMne,MACzBme,EAAK1C,OAASzb,KAAKyb,OACZ0C,CACT,EAMAzG,EAAWpX,UAAUif,WAAa,SAAUC,EAAYC,GACtD,IAAIC,EAAiB1f,KAAKwf,GAErBjN,EAAAA,WAAkBmN,KAIvB1f,KAAK2f,iBAAmB3f,KAAK2f,kBAAoB,GAEjD3f,KAAK2f,iBAAiB1c,KAAKuc,GAE3Bxf,KAAKwf,GAAc,WACjB,IAAII,EAAMF,EAAehT,MAAM1M,KAAMie,WACrC,OAAOwB,EAAe/S,MAAM1M,KAAM,CAAC4f,GAAKC,OAAOtN,EAAAA,MAAa0L,YAC9D,EACF,EAKAvG,EAAW/G,cAAgB,WACzBoG,EAAuB,SAAUvO,GAC/B,IAAIyQ,EAAqBzQ,EAAK4R,oBAC9B7H,EAAAA,KAAY0G,GAAoB,SAAUyE,EAAiBlX,GACzD,IAAI4B,EAAUI,EAAK0R,UAAU1T,GAEzBc,EAAcc,EAAQd,YACtB/C,EAAQiE,EAAKiT,OAEjB,GAAInU,EAAa,CACfoW,EAAkBzE,EAAmBzS,GAAO,IAAIhD,EAAe8D,EAAYuO,WAAWvW,QAGtF,IAAK,IAAIqC,EAAI,EAAGA,EAAI+b,EAAgBpe,OAAQqC,IAC1C+b,EAAgB/b,GAAK4V,EAGvB,IAAS5V,EAAI,EAAGA,EAAI4C,EAAMqC,QAASjF,IAEjC+b,EAAgBnZ,EAAM4C,IAAIiB,EAAQ6R,cAAetY,IAAMA,CAE3D,CACF,GACF,EAEAsV,EAAqB,SAAUzO,EAAMhE,EAAQ0E,GAC3C,OAAO4T,EAAAA,EAAAA,IAAoBtU,EAAK4U,aAAa5Y,EAAQ0E,GAAM,KAC7D,EAMA8N,EAAQ,SAAUxO,EAAMsC,GACtB,IAAIqG,EAAK3I,EAAKuP,QAAQjN,GAUtB,OARU,MAANqG,GAAgC,MAAlB3I,EAAKwR,YACrB7I,EAAK8F,EAAmBzO,EAAMA,EAAKwR,UAAWlP,IAGtC,MAANqG,IACFA,EAAKmG,EAAYxM,GAGZqG,CACT,EAEA+F,EAAsB,SAAUjQ,GAK9B,OAJKsL,EAAAA,QAAetL,KAClBA,EAA2B,MAAdA,EAAqB,CAACA,GAAc,IAG5CA,CACT,EAMAmQ,EAA2B,SAAUpG,GACnC,IAAImN,EAAO,IAAIzG,EAAW1G,EAAS8H,QAAU9H,EAAS8H,QAAUnW,EAAIqO,EAAS/J,WAAY+J,EAAS2J,YAAa3J,GAAWA,EAAS4G,WAGnI,OADAT,EAAmBgH,EAAMnN,GAClBmN,CACT,EAEAhH,EAAqB,SAAU5J,EAAQvH,GACrCuM,EAAAA,KAAYiF,EAAwBqI,OAAO7Z,EAAO2Z,kBAAoB,KAAK,SAAUG,GAC/E9Z,EAAO+U,eAAe+E,KACxBvS,EAAOuS,GAAY9Z,EAAO8Z,GAE9B,IACAvS,EAAOoS,iBAAmB3Z,EAAO2Z,iBACjCpN,EAAAA,KAAYkF,GAAkB,SAAUqI,GACtCvS,EAAOuS,GAAYvN,EAAAA,MAAavM,EAAO8Z,GACzC,IACAvS,EAAO+K,iBAAmB/F,EAAAA,OAAc,CAAC,EAAGvM,EAAOsS,iBACrD,EAEAjB,EAAiB,SAAU7O,EAAMU,GAC/B,IAAIwS,EAAWlT,EAAKsP,UAChB0E,EAAShU,EAAKuP,QACdgI,EAAavX,EAAKsR,YAClBkG,EAAWxX,EAAKwR,UAChBT,EAAOmC,EAASxS,GAChBiI,EAAKqL,EAAOtT,GAUhB,GARY,MAARqQ,GAA8B,MAAdwG,IAClBrE,EAASxS,GAAOqQ,EAAOtC,EAAmBzO,EAAMuX,EAAY7W,IAGpD,MAANiI,GAA0B,MAAZ6O,IAChBxD,EAAOtT,GAAOiI,EAAK8F,EAAmBzO,EAAMwX,EAAU9W,IAG9C,MAANiI,GAAsB,MAARoI,EAAc,CAC9B,IAAI0G,EAAkBzX,EAAKsT,iBACvBoE,EAAQD,EAAgB1G,IAAS0G,EAAgB1G,IAAS,GAAK,EACnEpI,EAAKoI,EAED2G,EAAQ,IACV/O,GAAM,SAAW+O,GAGnB1D,EAAOtT,GAAOiI,CAChB,CACF,CACF,CA3G2B,GA6GpBuG,CACT,CApmCA,GAsmCA,Q,uCCzoCI4B,EAEJ,WAIE,SAASA,EAAsB1D,GAkC7B5V,KAAK2Z,UAAY,CAAC,EAEP,MAAP/D,GACFrD,EAAAA,OAAcvS,KAAM4V,EAExB,CAEA,OAAO0D,CACT,CA9CA,GAiDA,Q,0OC/CI6G,EAEJ,WACE,SAASA,EAAWC,GAClBpgB,KAAKwI,KAAO4X,EAAO5X,OAAS4X,EAAOha,eAAiBia,EAAAA,GAA8B,CAAC,EAAI,IACvFrgB,KAAKoG,aAAega,EAAOha,cAAgBka,EAAAA,GAE3CtgB,KAAKugB,eAAiBH,EAAOG,gBAAkBC,EAAAA,GAC/CxgB,KAAKygB,WAAaL,EAAOK,YAAc,EACvCzgB,KAAK0gB,wBAA0BN,EAAOM,wBACtC1gB,KAAK2gB,cAAgBP,EAAOO,cAC5B,IAAIC,EAAmB5gB,KAAK4gB,iBAAmBR,EAAOQ,iBAEtD,GAAIA,EACF,IAAK,IAAIjf,EAAI,EAAGA,EAAIif,EAAiBthB,OAAQqC,IAAK,CAChD,IAAI6E,EAAMoa,EAAiBjf,GAEX,MAAZ6E,EAAIC,OACFoa,EAAAA,EAAAA,IAAa7gB,KAAM2B,KAAOmf,EAAAA,GAAAA,OAC5Bta,EAAIC,KAAO,UAGjB,CAEJ,CAEA,OAAO0Z,CACT,CAzBA,GA2BO,SAASvE,EAAiB/T,GAC/B,OAAOA,aAAesY,CACxB,CAMO,SAASY,EAAaC,EAAYC,EACzC7a,GACEA,EAAeA,GAAgB8a,EAAmBF,GAClD,IAAIT,EAAiBU,EAAkBV,eACnCY,EAAaC,EAA0BJ,EAAY5a,EAAcma,EAAgBU,EAAkBI,aAAcJ,EAAkBha,YACnIjB,EAAS,IAAIma,EAAW,CAC1B3X,KAAMwY,EACN5a,aAAcA,EACdma,eAAgBA,EAChBK,iBAAkBO,EAAWP,iBAC7BH,WAAYU,EAAWV,WACvBC,wBAAyBS,EAAWT,wBACpCC,eAAetU,EAAAA,EAAAA,OAAM4U,KAEvB,OAAOjb,CACT,CAKO,SAASsb,EAAiC9Y,GAC/C,OAAO,IAAI2X,EAAW,CACpB3X,KAAMA,EACNpC,cAAcmb,EAAAA,EAAAA,cAAa/Y,GAAQ+T,EAAAA,GAA4BG,EAAAA,IAEnE,CAKO,SAAS8E,EAAmBxb,GACjC,OAAO,IAAIma,EAAW,CACpB3X,KAAMxC,EAAOwC,KACbpC,aAAcJ,EAAOI,aACrBma,eAAgBva,EAAOua,eACvBK,kBAAkBvU,EAAAA,EAAAA,OAAMrG,EAAO4a,kBAC/BH,WAAYza,EAAOya,WACnBC,wBAAyB1a,EAAO0a,yBAEpC,CAKO,SAASQ,EAAmB1Y,GACjC,IAAIpC,EAAeka,EAAAA,GAEnB,IAAIiB,EAAAA,EAAAA,cAAa/Y,GACfpC,EAAemW,EAAAA,QACV,IAAIkF,EAAAA,EAAAA,SAAQjZ,GAAO,CAEJ,IAAhBA,EAAKlJ,SACP8G,EAAesb,EAAAA,IAGjB,IAAK,IAAI/f,EAAI,EAAGgG,EAAMa,EAAKlJ,OAAQqC,EAAIgG,EAAKhG,IAAK,CAC/C,IAAInC,EAAOgJ,EAAK7G,GAEhB,GAAY,MAARnC,EAAJ,CAEO,IAAIiiB,EAAAA,EAAAA,SAAQjiB,GAAO,CACxB4G,EAAesb,EAAAA,GACf,KACF,CAAO,IAAI5K,EAAAA,EAAAA,UAAStX,GAAO,CACzB4G,EAAeub,EAAAA,GACf,KACF,EACF,CACF,MAAO,IAAI7K,EAAAA,EAAAA,UAAStO,GAClB,IAAK,IAAIzF,KAAOyF,EACd,IAAIoZ,EAAAA,EAAAA,QAAOpZ,EAAMzF,KAAQ8e,EAAAA,EAAAA,aAAYrZ,EAAKzF,IAAO,CAC/CqD,EAAeia,EAAAA,GACf,KACF,CAIJ,OAAOja,CACT,CAMA,SAASgb,EAA0B5Y,EAAMpC,EAAcma,EAAgBc,EAKvET,GACE,IAAIF,EACAD,EAKJ,IAAKjY,EACH,MAAO,CACLoY,iBAAkBkB,EAA0BlB,GAC5CH,WAAYA,EACZC,wBAAyBA,GAI7B,GAAIta,IAAiBsb,EAAAA,GAA0B,CAC7C,IAAIK,EAAgBvZ,EAKC,SAAjB6Y,GAA2C,MAAhBA,EAC7BW,GAAqB,SAAUna,GAElB,MAAPA,GAAuB,MAARA,KACb+O,EAAAA,EAAAA,UAAS/O,GACG,MAAd4Y,IAAuBA,EAAa,GAEpCA,EAAa,EAInB,GAAGF,EAAgBwB,EAAe,IAElCtB,GAAawB,EAAAA,EAAAA,UAASZ,GAAgBA,EAAeA,EAAe,EAAI,EAGrET,GAAmC,IAAfH,IACvBG,EAAmB,GACnBoB,GAAqB,SAAUna,EAAK8O,GAClCiK,EAAiBjK,GAAgB,MAAP9O,EAAcA,EAAM,GAAK,EACrD,GAAG0Y,EAAgBwB,EAAe/d,MAGpC0c,EAA0BE,EAAmBA,EAAiBthB,OAASihB,IAAmB2B,EAAAA,GAAuBH,EAAcziB,OAASyiB,EAAc,GAAKA,EAAc,GAAGziB,OAAS,IACvL,MAAO,GAAI8G,IAAiBub,EAAAA,GACrBf,IACHA,EAAmBuB,EAA4B3Z,SAE5C,GAAIpC,IAAiBia,EAAAA,GACrBO,IACHA,EAAmB,IACnBpW,EAAAA,EAAAA,MAAKhC,GAAM,SAAU4Z,EAAQrf,GAC3B6d,EAAiB3d,KAAKF,EACxB,UAEG,GAAIqD,IAAiBsW,EAAAA,GAAwB,CAClD,IAAI2F,GAASC,EAAAA,EAAAA,IAAiB9Z,EAAK,IACnCkY,GAA0Be,EAAAA,EAAAA,SAAQY,IAAWA,EAAO/iB,QAAU,CAChE,MAA4Bid,EAAAA,GAM5B,MAAO,CACLkE,WAAYA,EACZG,iBAAkBkB,EAA0BlB,GAC5CF,wBAAyBA,EAE7B,CAEA,SAASyB,EAA4B3Z,GACnC,IACIgI,EADA+R,EAAa,EAGjB,MAAOA,EAAa/Z,EAAKlJ,UAAYkR,EAAMhI,EAAK+Z,OAGhD,GAAI/R,EACF,OAAO1D,EAAAA,EAAAA,MAAK0D,EAEhB,CAKA,SAASsR,EAA0BlB,GACjC,GAAKA,EAAL,CAKA,IAAI4B,GAAUjd,EAAAA,EAAAA,iBACd,OAAO5C,EAAAA,EAAAA,KAAIie,GAAkB,SAAU6B,EAAS9L,GAC9C8L,GAAU3L,EAAAA,EAAAA,UAAS2L,GAAWA,EAAU,CACtClJ,KAAMkJ,GAGR,IAAIjjB,EAAO,CACT+Z,KAAMkJ,EAAQlJ,KACdmJ,YAAaD,EAAQC,YACrBjc,KAAMgc,EAAQhc,MAKhB,GAAiB,MAAbjH,EAAK+Z,KACP,OAAO/Z,EAITA,EAAK+Z,MAAQ,GAMW,MAApB/Z,EAAKkjB,cACPljB,EAAKkjB,YAAcljB,EAAK+Z,MAG1B,IAAIoJ,EAAQH,EAAQrb,IAAI3H,EAAK+Z,MAU7B,OARKoJ,EAKHnjB,EAAK+Z,MAAQ,IAAMoJ,EAAM/b,QAJzB4b,EAAQpb,IAAI5H,EAAK+Z,KAAM,CACrB3S,MAAO,IAMJpH,CACT,GA1CA,CA2CF,CAEA,SAASwiB,EAAqB5V,EAAImU,EAAgB/X,EAAMoa,GACtD,GAAIrC,IAAmB2B,EAAAA,GACrB,IAAK,IAAIvgB,EAAI,EAAGA,EAAI6G,EAAKlJ,QAAUqC,EAAIihB,EAASjhB,IAC9CyK,EAAG5D,EAAK7G,GAAK6G,EAAK7G,GAAG,GAAK,KAAMA,OAGlC,KAAI0gB,EAAS7Z,EAAK,IAAM,GAExB,IAAS7G,EAAI,EAAGA,EAAI0gB,EAAO/iB,QAAUqC,EAAIihB,EAASjhB,IAChDyK,EAAGiW,EAAO1gB,GAAIA,EAHU,CAM9B,CAEO,SAAS2E,EAAyBN,GACvC,IAAII,EAAeJ,EAAOI,aAC1B,OAAOA,IAAiBub,EAAAA,IAA6Bvb,IAAiBia,EAAAA,EACxE,C,2FCnRIwC,EAEJ,WACE,SAASA,EAAStJ,EAAMuJ,GACtB9iB,KAAK+iB,MAAQ,EACb/iB,KAAKgjB,OAAS,EASdhjB,KAAK0L,WAAa,EAClB1L,KAAKijB,SAAW,GAChBjjB,KAAKkjB,aAAe,GACpBljB,KAAKmjB,UAAW,EAChBnjB,KAAKuZ,KAAOA,GAAQ,GACpBvZ,KAAK8iB,SAAWA,CAClB,CAwOA,OAlOAD,EAASviB,UAAU8iB,UAAY,WAC7B,OAAOpjB,KAAK0L,UAAY,CAC1B,EAEAmX,EAASviB,UAAUyS,SAAW,SAAUsQ,EAASjX,EAAItM,GAC/CyS,EAAAA,WAAkB8Q,KACpBvjB,EAAUsM,EACVA,EAAKiX,EACLA,EAAU,MAGZA,EAAUA,GAAW,CAAC,EAElB9Q,EAAAA,SAAgB8Q,KAClBA,EAAU,CACRC,MAAOD,IAIX,IAEIE,EAFAD,EAAQD,EAAQC,OAAS,WACzBL,EAAWjjB,KAAKqjB,EAAQG,MAAQ,YAE1B,aAAVF,IAAyBC,EAAmBnX,EAAG/C,KAAKvJ,EAASE,OAE7D,IAAK,IAAI2B,EAAI,GAAI4hB,GAAoB5hB,EAAIshB,EAAS3jB,OAAQqC,IACxDshB,EAASthB,GAAGoR,SAASsQ,EAASjX,EAAItM,GAG1B,cAAVwjB,GAAyBlX,EAAG/C,KAAKvJ,EAASE,KAC5C,EAMA6iB,EAASviB,UAAUmjB,qBAAuB,SAAUV,GAClD,IAAIC,EAAS,EACbhjB,KAAK+iB,MAAQA,EAEb,IAAK,IAAIphB,EAAI,EAAGA,EAAI3B,KAAKijB,SAAS3jB,OAAQqC,IAAK,CAC7C,IAAI+hB,EAAQ1jB,KAAKijB,SAASthB,GAC1B+hB,EAAMD,qBAAqBV,EAAQ,GAE/BW,EAAMV,OAASA,IACjBA,EAASU,EAAMV,OAEnB,CAEAhjB,KAAKgjB,OAASA,EAAS,CACzB,EAEAH,EAASviB,UAAU4R,YAAc,SAAUf,GACzC,GAAInR,KAAKgX,UAAY7F,EACnB,OAAOnR,KAGT,IAAK,IAAI2B,EAAI,EAAGshB,EAAWjjB,KAAKijB,SAAUtb,EAAMsb,EAAS3jB,OAAQqC,EAAIgG,EAAKhG,IAAK,CAC7E,IAAIie,EAAMqD,EAASthB,GAAGuQ,YAAYf,GAElC,GAAIyO,EACF,OAAOA,CAEX,CACF,EAEAiD,EAASviB,UAAUqjB,SAAW,SAAU7R,GACtC,GAAIA,IAAS9R,KACX,OAAO,EAGT,IAAK,IAAI2B,EAAI,EAAGshB,EAAWjjB,KAAKijB,SAAUtb,EAAMsb,EAAS3jB,OAAQqC,EAAIgG,EAAKhG,IAAK,CAC7E,IAAIie,EAAMqD,EAASthB,GAAGgiB,SAAS7R,GAE/B,GAAI8N,EACF,OAAOA,CAEX,CACF,EAOAiD,EAASviB,UAAUsjB,aAAe,SAAUC,GAC1C,IAAIC,EAAY,GACZhS,EAAO+R,EAAc7jB,KAAOA,KAAK+jB,WAErC,MAAOjS,EACLgS,EAAU7gB,KAAK6O,GACfA,EAAOA,EAAKiS,WAId,OADAD,EAAUE,UACHF,CACT,EAEAjB,EAASviB,UAAU2jB,oBAAsB,WACvC,IAAIlZ,EAAU,GACVmZ,EAAWlkB,KAEf,MAAOkkB,EACLnZ,EAAQ9H,KAAKihB,EAASxY,WACtBwY,EAAWA,EAASH,WAItB,OADAhZ,EAAQiZ,UACDjZ,CACT,EAEA8X,EAASviB,UAAU6jB,qBAAuB,WACxC,IAAIpZ,EAAU,GAId,OAHA/K,KAAK+S,UAAS,SAAUqR,GACtBrZ,EAAQ9H,KAAKmhB,EAAU1Y,UACzB,IACOX,CACT,EAEA8X,EAASviB,UAAUqU,SAAW,SAAUnF,GACtC,IAAIhH,EAAOxI,KAAK8iB,SAASta,KACzB,OAAOA,EAAKoM,WAAWzN,IAAIqB,EAAKqM,kBAAkBrF,GAAa,SAAUxP,KAAK0L,UAChF,EAEAmX,EAASviB,UAAU4U,UAAY,SAAUC,EAAQC,GAC/CpV,KAAK0L,WAAa,GAAK1L,KAAK8iB,SAASta,KAAK6M,cAAcrV,KAAK0L,UAAWyJ,EAAQC,EAClF,EAMAyN,EAASviB,UAAUgV,UAAY,WAC7B,OAAOtV,KAAK8iB,SAASta,KAAK+M,cAAcvV,KAAK0L,UAC/C,EAKAmX,EAASviB,UAAU2T,SAAW,SAAUC,GACtC,KAAIlU,KAAK0L,UAAY,GAArB,CAIA,IAAIoX,EAAW9iB,KAAK8iB,SAChB3O,EAAY2O,EAASta,KAAK4L,aAAapU,KAAK0L,WAChD,OAAOyI,EAAUF,SAASC,EAJ1B,CAKF,EAGA2O,EAASviB,UAAU+jB,cAAgB,WACjC,OAAQrkB,KAAK8iB,SAASwB,aAAe,IAAItkB,KAAK+iB,MAChD,EAEAF,EAASviB,UAAUwU,UAAY,SAAU/R,EAAKsH,GAC5CrK,KAAK0L,WAAa,GAAK1L,KAAK8iB,SAASta,KAAKuM,cAAc/U,KAAK0L,UAAW3I,EAAKsH,EAC/E,EAOAwY,EAASviB,UAAU0U,UAAY,SAAUjS,GACvC,OAAO/C,KAAK8iB,SAASta,KAAKyM,cAAcjV,KAAK0L,UAAW3I,EAC1D,EAEA8f,EAASviB,UAAUwF,YAAc,WAC/B,OAAO9F,KAAK8iB,SAASta,KAAK1C,YAAY9F,KAAK0L,UAC7C,EAEAmX,EAASviB,UAAU0W,MAAQ,WACzB,OAAOhX,KAAK8iB,SAASta,KAAKwO,MAAMhX,KAAK0L,UACvC,EAMAmX,EAASviB,UAAUikB,cAAgB,WACjC,GAAIvkB,KAAK+jB,WAAY,CAGnB,IAFA,IAAId,EAAWjjB,KAAK+jB,WAAWd,SAEtBthB,EAAI,EAAGA,EAAIshB,EAAS3jB,SAAUqC,EACrC,GAAIshB,EAASthB,KAAO3B,KAClB,OAAO2B,EAIX,OAAQ,CACV,CAEA,OAAQ,CACV,EASAkhB,EAASviB,UAAUkkB,aAAe,SAAU1S,GAC1C,IAAI2S,EAAS3S,EAAKiS,WAElB,MAAOU,EAAQ,CACb,GAAIA,IAAWzkB,KACb,OAAO,EAGTykB,EAASA,EAAOV,UAClB,CAEA,OAAO,CACT,EASAlB,EAASviB,UAAUokB,eAAiB,SAAU5S,GAC5C,OAAOA,IAAS9R,MAAQ8R,EAAK0S,aAAaxkB,KAC5C,EAEO6iB,CACT,CA3PA,GAgQI8B,EAEJ,WACE,SAASA,EAAK/M,GACZ5X,KAAKyG,KAAO,OACZzG,KAAK4kB,OAAS,GACd5kB,KAAK4X,UAAYA,CACnB,CAkGA,OAhGA+M,EAAKrkB,UAAUyS,SAAW,SAAUsQ,EAASjX,EAAItM,GAC/CE,KAAK6kB,KAAK9R,SAASsQ,EAASjX,EAAItM,EAClC,EAEA6kB,EAAKrkB,UAAUwkB,mBAAqB,SAAUpZ,GAC5C,IAAIZ,EAAW9K,KAAKwI,KAAK1C,YAAY4F,GACrC,OAAO1L,KAAK4kB,OAAO9Z,EACrB,EAEA6Z,EAAKrkB,UAAU4R,YAAc,SAAUqH,GACrC,OAAOvZ,KAAK6kB,KAAK3S,YAAYqH,EAC/B,EAOAoL,EAAKrkB,UAAUI,OAAS,WAItB,IAHA,IAAI8H,EAAOxI,KAAKwI,KACZ8I,EAAQtR,KAAK4kB,OAERjjB,EAAI,EAAGgG,EAAM2J,EAAMhS,OAAQqC,EAAIgG,EAAKhG,IAC3C2P,EAAM3P,GAAG+J,WAAa,EAGxB,IAAS/J,EAAI,EAAGgG,EAAMa,EAAK5B,QAASjF,EAAIgG,EAAKhG,IAC3C2P,EAAM9I,EAAK1C,YAAYnE,IAAI+J,UAAY/J,CAE3C,EAMAgjB,EAAKrkB,UAAUykB,aAAe,WAC5B/kB,KAAKwI,KAAKuW,kBACZ,EAkBA4F,EAAKK,WAAa,SAAUC,EAAUrN,EAAWsN,GAC/C,IAAIC,EAAO,IAAIR,EAAK/M,GAChBwN,EAAW,GACXC,EAAS,EAGb,SAASC,EAAeC,EAAUxB,GAChC,IAAI1Z,EAAQkb,EAASlb,MACrBgb,EAASrd,KAAKE,IAAImd,EAAQ9S,EAAAA,QAAelI,GAASA,EAAM/K,OAAS,GACjE8lB,EAASniB,KAAKsiB,GACd,IAAIzT,EAAO,IAAI+Q,GAAS/F,EAAAA,EAAAA,IAAoByI,EAAShM,KAAM,IAAK4L,GAChEpB,EAAayB,EAAS1T,EAAMiS,GAAcoB,EAAKN,KAAO/S,EAEtDqT,EAAKP,OAAO3hB,KAAK6O,GAEjB,IAAImR,EAAWsC,EAAStC,SAExB,GAAIA,EACF,IAAK,IAAIthB,EAAI,EAAGA,EAAIshB,EAAS3jB,OAAQqC,IACnC2jB,EAAerC,EAASthB,GAAImQ,EAGlC,CAlBAwT,EAAeL,GAoBfE,EAAKN,KAAKpB,qBAAqB,GAC/B,IAAIxc,GAAawe,EAAAA,EAAAA,GAAwBL,EAAU,CACjDM,gBAAiB,CAAC,SAClBC,gBAAiBN,IAChBpe,WACCkX,EAAO,IAAIzG,EAAAA,EAAWzQ,EAAY2Q,GAStC,OARAuG,EAAK3Y,SAAS4f,GACdF,GAAcA,EAAW/G,IACzByH,EAAAA,EAAAA,GAAe,CACbC,SAAU1H,EACV2H,OAAQX,EACRY,WAAY,SAEdZ,EAAKzkB,SACEykB,CACT,EAEOR,CACT,CAxGA,GA+GA,SAASa,EAAS9B,EAAO5R,GACvB,IAAImR,EAAWnR,EAAKmR,SAEhBS,EAAMK,aAAejS,IAIzBmR,EAAShgB,KAAKygB,GACdA,EAAMK,WAAajS,EACrB,CAEA,Q","sources":["webpack://databoard/./node_modules/echarts/lib/data/DataDiffer.js","webpack://databoard/./node_modules/echarts/lib/data/DataStore.js","webpack://databoard/./node_modules/echarts/lib/data/Graph.js","webpack://databoard/./node_modules/echarts/lib/data/OrdinalMeta.js","webpack://databoard/./node_modules/echarts/lib/data/SeriesData.js","webpack://databoard/./node_modules/echarts/lib/data/SeriesDimensionDefine.js","webpack://databoard/./node_modules/echarts/lib/data/Source.js","webpack://databoard/./node_modules/echarts/lib/data/Tree.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated until needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retrieve the index with given raw data index.\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retrieve the index of nearest value.\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices have\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we choose the one that `diff >= 0` in this case.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangle with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js'; // id may be function name of Object, add a prefix to avoid this problem.\n\nfunction generateNodeKey(id) {\n  return '_EC_' + id;\n}\n\nvar Graph =\n/** @class */\nfunction () {\n  function Graph(directed) {\n    this.type = 'graph';\n    this.nodes = [];\n    this.edges = [];\n    this._nodesMap = {};\n    /**\n     * @type {Object.<string, module:echarts/data/Graph.Edge>}\n     * @private\n     */\n\n    this._edgesMap = {};\n    this._directed = directed || false;\n  }\n  /**\n   * If is directed graph\n   */\n\n\n  Graph.prototype.isDirected = function () {\n    return this._directed;\n  };\n\n  ;\n  /**\n   * Add a new node\n   */\n\n  Graph.prototype.addNode = function (id, dataIndex) {\n    id = id == null ? '' + dataIndex : '' + id;\n    var nodesMap = this._nodesMap;\n\n    if (nodesMap[generateNodeKey(id)]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Graph nodes have duplicate name or id');\n      }\n\n      return;\n    }\n\n    var node = new GraphNode(id, dataIndex);\n    node.hostGraph = this;\n    this.nodes.push(node);\n    nodesMap[generateNodeKey(id)] = node;\n    return node;\n  };\n\n  ;\n  /**\n   * Get node by data index\n   */\n\n  Graph.prototype.getNodeByIndex = function (dataIndex) {\n    var rawIdx = this.data.getRawIndex(dataIndex);\n    return this.nodes[rawIdx];\n  };\n\n  ;\n  /**\n   * Get node by id\n   */\n\n  Graph.prototype.getNodeById = function (id) {\n    return this._nodesMap[generateNodeKey(id)];\n  };\n\n  ;\n  /**\n   * Add a new edge\n   */\n\n  Graph.prototype.addEdge = function (n1, n2, dataIndex) {\n    var nodesMap = this._nodesMap;\n    var edgesMap = this._edgesMap; // PENDING\n\n    if (zrUtil.isNumber(n1)) {\n      n1 = this.nodes[n1];\n    }\n\n    if (zrUtil.isNumber(n2)) {\n      n2 = this.nodes[n2];\n    }\n\n    if (!(n1 instanceof GraphNode)) {\n      n1 = nodesMap[generateNodeKey(n1)];\n    }\n\n    if (!(n2 instanceof GraphNode)) {\n      n2 = nodesMap[generateNodeKey(n2)];\n    }\n\n    if (!n1 || !n2) {\n      return;\n    }\n\n    var key = n1.id + '-' + n2.id;\n    var edge = new GraphEdge(n1, n2, dataIndex);\n    edge.hostGraph = this;\n\n    if (this._directed) {\n      n1.outEdges.push(edge);\n      n2.inEdges.push(edge);\n    }\n\n    n1.edges.push(edge);\n\n    if (n1 !== n2) {\n      n2.edges.push(edge);\n    }\n\n    this.edges.push(edge);\n    edgesMap[key] = edge;\n    return edge;\n  };\n\n  ;\n  /**\n   * Get edge by data index\n   */\n\n  Graph.prototype.getEdgeByIndex = function (dataIndex) {\n    var rawIdx = this.edgeData.getRawIndex(dataIndex);\n    return this.edges[rawIdx];\n  };\n\n  ;\n  /**\n   * Get edge by two linked nodes\n   */\n\n  Graph.prototype.getEdge = function (n1, n2) {\n    if (n1 instanceof GraphNode) {\n      n1 = n1.id;\n    }\n\n    if (n2 instanceof GraphNode) {\n      n2 = n2.id;\n    }\n\n    var edgesMap = this._edgesMap;\n\n    if (this._directed) {\n      return edgesMap[n1 + '-' + n2];\n    } else {\n      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n    }\n  };\n\n  ;\n  /**\n   * Iterate all nodes\n   */\n\n  Graph.prototype.eachNode = function (cb, context) {\n    var nodes = this.nodes;\n    var len = nodes.length;\n\n    for (var i = 0; i < len; i++) {\n      if (nodes[i].dataIndex >= 0) {\n        cb.call(context, nodes[i], i);\n      }\n    }\n  };\n\n  ;\n  /**\n   * Iterate all edges\n   */\n\n  Graph.prototype.eachEdge = function (cb, context) {\n    var edges = this.edges;\n    var len = edges.length;\n\n    for (var i = 0; i < len; i++) {\n      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n        cb.call(context, edges[i], i);\n      }\n    }\n  };\n\n  ;\n  /**\n   * Breadth first traverse\n   * Return true to stop traversing\n   */\n\n  Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {\n    if (!(startNode instanceof GraphNode)) {\n      startNode = this._nodesMap[generateNodeKey(startNode)];\n    }\n\n    if (!startNode) {\n      return;\n    }\n\n    var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].__visited = false;\n    }\n\n    if (cb.call(context, startNode, null)) {\n      return;\n    }\n\n    var queue = [startNode];\n\n    while (queue.length) {\n      var currentNode = queue.shift();\n      var edges = currentNode[edgeType];\n\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n\n        if (!otherNode.__visited) {\n          if (cb.call(context, otherNode, currentNode)) {\n            // Stop traversing\n            return;\n          }\n\n          queue.push(otherNode);\n          otherNode.__visited = true;\n        }\n      }\n    }\n  };\n\n  ; // TODO\n  // depthFirstTraverse(\n  //     cb, startNode, direction, context\n  // ) {\n  // };\n  // Filter update\n\n  Graph.prototype.update = function () {\n    var data = this.data;\n    var edgeData = this.edgeData;\n    var nodes = this.nodes;\n    var edges = this.edges;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n\n    edgeData.filterSelf(function (idx) {\n      var edge = edges[edgeData.getRawIndex(idx)];\n      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n    }); // Update edge\n\n    for (var i = 0, len = edges.length; i < len; i++) {\n      edges[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = edgeData.count(); i < len; i++) {\n      edges[edgeData.getRawIndex(i)].dataIndex = i;\n    }\n  };\n\n  ;\n  /**\n   * @return {module:echarts/data/Graph}\n   */\n\n  Graph.prototype.clone = function () {\n    var graph = new Graph(this._directed);\n    var nodes = this.nodes;\n    var edges = this.edges;\n\n    for (var i = 0; i < nodes.length; i++) {\n      graph.addNode(nodes[i].id, nodes[i].dataIndex);\n    }\n\n    for (var i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n    }\n\n    return graph;\n  };\n\n  ;\n  return Graph;\n}();\n\nvar GraphNode =\n/** @class */\nfunction () {\n  function GraphNode(id, dataIndex) {\n    this.inEdges = [];\n    this.outEdges = [];\n    this.edges = [];\n    this.dataIndex = -1;\n    this.id = id == null ? '' : id;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  GraphNode.prototype.degree = function () {\n    return this.edges.length;\n  };\n  /**\n   * @return {number}\n   */\n\n\n  GraphNode.prototype.inDegree = function () {\n    return this.inEdges.length;\n  };\n  /**\n  * @return {number}\n  */\n\n\n  GraphNode.prototype.outDegree = function () {\n    return this.outEdges.length;\n  };\n\n  GraphNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var graph = this.hostGraph;\n    var itemModel = graph.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n\n  GraphNode.prototype.getAdjacentDataIndices = function () {\n    var dataIndices = {\n      edge: [],\n      node: []\n    };\n\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n\n      dataIndices.edge.push(adjacentEdge.dataIndex);\n      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);\n    }\n\n    return dataIndices;\n  };\n\n  return GraphNode;\n}();\n\nvar GraphEdge =\n/** @class */\nfunction () {\n  function GraphEdge(n1, n2, dataIndex) {\n    this.dataIndex = -1;\n    this.node1 = n1;\n    this.node2 = n2;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  GraphEdge.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var graph = this.hostGraph;\n    var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n\n  GraphEdge.prototype.getAdjacentDataIndices = function () {\n    return {\n      edge: [this.dataIndex],\n      node: [this.node1.dataIndex, this.node2.dataIndex]\n    };\n  };\n\n  return GraphEdge;\n}();\n\nfunction createGraphDataProxyMixin(hostName, dataName) {\n  return {\n    /**\n     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\n     */\n    getValue: function (dimension) {\n      var data = this[hostName][dataName];\n      return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n    },\n    // TODO: TYPE stricter type.\n    setVisual: function (key, value) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n    },\n    getVisual: function (key) {\n      return this[hostName][dataName].getItemVisual(this.dataIndex, key);\n    },\n    setLayout: function (layout, merge) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n    },\n    getLayout: function () {\n      return this[hostName][dataName].getItemLayout(this.dataIndex);\n    },\n    getGraphicEl: function () {\n      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n    },\n    getRawIndex: function () {\n      return this[hostName][dataName].getRawIndex(this.dataIndex);\n    }\n  };\n}\n\n;\n;\n;\nzrUtil.mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));\nzrUtil.mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\nexport default Graph;\nexport { GraphNode, GraphEdge };","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, map, isString } from 'zrender/lib/core/util.js';\nvar uidBase = 0;\n\nvar OrdinalMeta =\n/** @class */\nfunction () {\n  function OrdinalMeta(opt) {\n    this.categories = opt.categories || [];\n    this._needCollect = opt.needCollect;\n    this._deduplication = opt.deduplication;\n    this.uid = ++uidBase;\n  }\n\n  OrdinalMeta.createByAxisModel = function (axisModel) {\n    var option = axisModel.option;\n    var data = option.data;\n    var categories = data && map(data, getName);\n    return new OrdinalMeta({\n      categories: categories,\n      needCollect: !categories,\n      // deduplication is default in axis.\n      deduplication: option.dedplication !== false\n    });\n  };\n\n  ;\n\n  OrdinalMeta.prototype.getOrdinal = function (category) {\n    // @ts-ignore\n    return this._getOrCreateMap().get(category);\n  };\n  /**\n   * @return The ordinal. If not found, return NaN.\n   */\n\n\n  OrdinalMeta.prototype.parseAndCollect = function (category) {\n    var index;\n    var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.\n    // This feature is only supported when !needCollect, because we should\n    // consider a common case: a value is 2017, which is a number but is\n    // expected to be tread as a category. This case usually happen in dataset,\n    // where it happent to be no need of the index feature.\n\n    if (!isString(category) && !needCollect) {\n      return category;\n    } // Optimize for the scenario:\n    // category is ['2012-01-01', '2012-01-02', ...], where the input\n    // data has been ensured not duplicate and is large data.\n    // Notice, if a dataset dimension provide categroies, usually echarts\n    // should remove duplication except user tell echarts dont do that\n    // (set axis.deduplication = false), because echarts do not know whether\n    // the values in the category dimension has duplication (consider the\n    // parallel-aqi example)\n\n\n    if (needCollect && !this._deduplication) {\n      index = this.categories.length;\n      this.categories[index] = category;\n      return index;\n    }\n\n    var map = this._getOrCreateMap(); // @ts-ignore\n\n\n    index = map.get(category);\n\n    if (index == null) {\n      if (needCollect) {\n        index = this.categories.length;\n        this.categories[index] = category; // @ts-ignore\n\n        map.set(category, index);\n      } else {\n        index = NaN;\n      }\n    }\n\n    return index;\n  }; // Consider big data, do not create map until needed.\n\n\n  OrdinalMeta.prototype._getOrCreateMap = function () {\n    return this._map || (this._map = createHashMap(this.categories));\n  };\n\n  return OrdinalMeta;\n}();\n\nfunction getName(obj) {\n  if (isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nexport default OrdinalMeta;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\n\nvar SeriesData =\n/** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n\n    this._initGetDimensionInfo(needsHasOwn);\n\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx == null) {\n      return dim;\n    }\n\n    dimIdx = dim;\n\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n\n    if (dimName != null) {\n      return dimName;\n    }\n\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n\n    if (dim == null) {\n      return -1;\n    }\n\n    var dimInfo = this._getDimInfo(dim);\n\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n\n    var store;\n\n    if (data instanceof DataStore) {\n      store = data;\n    }\n\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n        start = _a.start,\n        end = _a.end;\n\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n\n    this._updateOrdinalMeta();\n\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n\n    var store = this._store;\n    var provider = store.getProvider();\n\n    this._updateOrdinalMeta();\n\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        if (dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return SeriesData;\n}();\n\nexport default SeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\n\nvar SeriesDimensionDefine =\n/** @class */\nfunction () {\n  /**\n   * @param opt All of the fields will be shallow copied.\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\n     * The format of `otherDims` is:\n     * ```js\n     * {\n     *     tooltip?: number\n     *     label?: number\n     *     itemName?: number\n     *     seriesName?: number\n     * }\n     * ```\n     *\n     * A `series.encode` can specified these fields:\n     * ```js\n     * encode: {\n     *     // \"3, 1, 5\" is the index of data dimension.\n     *     tooltip: [3, 1, 5],\n     *     label: [0, 3],\n     *     ...\n     * }\n     * ```\n     * `otherDims` is the parse result of the `series.encode` above, like:\n     * ```js\n     * // Suppose the index of this data dimension is `3`.\n     * this.otherDims = {\n     *     // `3` is at the index `0` of the `encode.tooltip`\n     *     tooltip: 0,\n     *     // `3` is at the index `1` of the `encode.label`\n     *     label: 1\n     * };\n     * ```\n     *\n     * This prop should never be `null`/`undefined` after initialized.\n     */\n    this.otherDims = {};\n\n    if (opt != null) {\n      zrUtil.extend(this, opt);\n    }\n  }\n\n  return SeriesDimensionDefine;\n}();\n\n;\nexport default SeriesDimensionDefine;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { isTypedArray, clone, createHashMap, isArray, isObject, isArrayLike, hasOwn, assert, each, map, isNumber, isString, keys } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_UNKNOWN, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW } from '../util/types.js';\nimport { getDataItemValue } from '../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './helper/sourceHelper.js';\n; // @inner\n\nvar SourceImpl =\n/** @class */\nfunction () {\n  function SourceImpl(fields) {\n    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);\n    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN; // Visit config\n\n    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;\n    this.startIndex = fields.startIndex || 0;\n    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;\n    this.metaRawOption = fields.metaRawOption;\n    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;\n\n    if (dimensionsDefine) {\n      for (var i = 0; i < dimensionsDefine.length; i++) {\n        var dim = dimensionsDefine[i];\n\n        if (dim.type == null) {\n          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {\n            dim.type = 'ordinal';\n          }\n        }\n      }\n    }\n  }\n\n  return SourceImpl;\n}();\n\nexport function isSourceInstance(val) {\n  return val instanceof SourceImpl;\n}\n/**\n * Create a source from option.\n * NOTE: Created source is immutable. Don't change any properties in it.\n */\n\nexport function createSource(sourceData, thisMetaRawOption, // can be null. If not provided, auto detect it from `sourceData`.\nsourceFormat) {\n  sourceFormat = sourceFormat || detectSourceFormat(sourceData);\n  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;\n  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);\n  var source = new SourceImpl({\n    data: sourceData,\n    sourceFormat: sourceFormat,\n    seriesLayoutBy: seriesLayoutBy,\n    dimensionsDefine: determined.dimensionsDefine,\n    startIndex: determined.startIndex,\n    dimensionsDetectedCount: determined.dimensionsDetectedCount,\n    metaRawOption: clone(thisMetaRawOption)\n  });\n  return source;\n}\n/**\n * Wrap original series data for some compatibility cases.\n */\n\nexport function createSourceFromSeriesDataOption(data) {\n  return new SourceImpl({\n    data: data,\n    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL\n  });\n}\n/**\n * Clone source but excludes source data.\n */\n\nexport function cloneSourceShallow(source) {\n  return new SourceImpl({\n    data: source.data,\n    sourceFormat: source.sourceFormat,\n    seriesLayoutBy: source.seriesLayoutBy,\n    dimensionsDefine: clone(source.dimensionsDefine),\n    startIndex: source.startIndex,\n    dimensionsDetectedCount: source.dimensionsDetectedCount\n  });\n}\n/**\n * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.\n */\n\nexport function detectSourceFormat(data) {\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (hasOwn(data, key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  }\n\n  return sourceFormat;\n}\n/**\n * Determine the source definitions from data standalone dimensions definitions\n * are not specified.\n */\n\nfunction determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, // standalone raw dimensions definition, like:\n// {\n//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]\n// }\n// in `dataset` or `series`\ndimensionsDefine) {\n  var dimensionsDetectedCount;\n  var startIndex; // PENDING: Could data be null/undefined here?\n  // currently, if `dataset.source` not specified, error thrown.\n  // if `series.data` not specified, nothing rendered without error thrown.\n  // Should test these cases.\n\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n      startIndex: startIndex,\n      dimensionsDetectedCount: dimensionsDetectedCount\n    };\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data; // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, dataArrayRows, 10);\n    } else {\n      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val + '' : '';\n      }, seriesLayoutBy, dataArrayRows, Infinity);\n    }\n\n    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectedCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');\n    }\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n    dimensionsDetectedCount: dimensionsDetectedCount\n  };\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    return keys(obj);\n  }\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefined or string.\n\n\nfunction normalizeDimensionsOption(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (rawItem, index) {\n    rawItem = isObject(rawItem) ? rawItem : {\n      name: rawItem\n    }; // Other fields will be discarded.\n\n    var item = {\n      name: rawItem.name,\n      displayName: rawItem.displayName,\n      type: rawItem.type\n    }; // User can set null in dimensions.\n    // We don't auto specify name, otherwise a given name may\n    // cause it to be referred unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nexport function shouldRetrieveDataByName(source) {\n  var sourceFormat = source.sourceFormat;\n  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Tree data structure\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport linkSeriesData from './helper/linkSeriesData.js';\nimport SeriesData from './SeriesData.js';\nimport prepareSeriesDataSchema from './helper/createDimensions.js';\nimport { convertOptionIdName } from '../util/model.js';\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     */\n\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\n   * The node is removed.\n   */\n\n\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrUtil.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\n   * Update depth and height of this subtree.\n   */\n\n\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n\n    this.height = height + 1;\n  };\n\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\n   * @param includeSelf Default false.\n   * @return order: [root, child, grandchild, ...]\n   */\n\n\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n\n    ancestors.reverse();\n    return ancestors;\n  };\n\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n\n    indices.reverse();\n    return indices;\n  };\n\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\n   * @return {Object} layout\n   */\n\n\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  }; // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  }; // TODO: TYPE More specific model\n\n\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\n   * Get item visual\n   * FIXME: make return type better\n   */\n\n\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\n   * index in parent's children\n   */\n\n\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    return -1;\n  };\n  /**\n   * if this is an ancestor of another node\n   *\n   * @param node another node\n   * @return if is ancestor\n   */\n\n\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return false;\n  };\n  /**\n   * if this is an descendant of another node\n   *\n   * @param node another node\n   * @return if is descendant\n   */\n\n\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n\n  return TreeNode;\n}();\n\nexport { TreeNode };\n;\n\nvar Tree =\n/** @class */\nfunction () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n\n\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\n   * Clear all layouts\n   */\n\n\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\n   * data node format:\n   * {\n   *     name: ...\n   *     value: ...\n   *     children: [\n   *         {\n   *             name: ...\n   *             value: ...\n   *             children: ...\n   *         },\n   *         ...\n   *     ]\n   * }\n   */\n\n\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n\n      tree._nodes.push(node);\n\n      var children = dataNode.children;\n\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = prepareSeriesDataSchema(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new SeriesData(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    linkSeriesData({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n\n  return Tree;\n}();\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n */\n\n\nfunction addChild(child, node) {\n  var children = node.children;\n\n  if (child.parentNode === node) {\n    return;\n  }\n\n  children.push(child);\n  child.parentNode = node;\n}\n\nexport default Tree;"],"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","this","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push","defaultDimValueGetters","UNDEFINED","CtorUint32Array","Uint32Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","newStore","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","createHashMap","initData","provider","inputDimensions","dimValueGetter","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","shouldRetrieveDataByName","_dimensions","dim","type","property","_initDataFromProvider","count","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","getItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","getByRawIndex","rawIdx","getSum","dimData","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","clone","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","keys","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","maxArea","area","nextRawIndex","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","dimExtent","currEnd","useRaw","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","reduce","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","parseDataValue","objectRows","keyedColumns","original","typedArray","generateNodeKey","id","Graph","directed","nodes","edges","_nodesMap","_edgesMap","_directed","isDirected","addNode","nodesMap","node","GraphNode","hostGraph","getNodeByIndex","getNodeById","addEdge","n1","n2","edgesMap","zrUtil","edge","GraphEdge","outEdges","inEdges","getEdgeByIndex","edgeData","getEdge","eachNode","eachEdge","node1","node2","breadthFirstTraverse","startNode","direction","edgeType","__visited","queue","currentNode","e","otherNode","filterSelf","graph","degree","inDegree","outDegree","getModel","path","itemModel","getItemModel","getAdjacentDataIndices","dataIndices","adjacentEdge","createGraphDataProxyMixin","hostName","dataName","getValue","getStore","getDimensionIndex","setVisual","setItemVisual","getVisual","getItemVisual","setLayout","layout","merge","setItemLayout","getLayout","getItemLayout","getGraphicEl","getItemGraphicEl","uidBase","OrdinalMeta","opt","categories","_needCollect","needCollect","_deduplication","deduplication","uid","createByAxisModel","axisModel","option","getName","dedplication","getOrdinal","category","_getOrCreateMap","index","isString","_map","isObject","prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","ID_PREFIX","INDEX_NOT_FOUND","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","SeriesData","dimensionsInput","hostModel","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","assignStoreDimIdx","isSeriesDataSchema","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","dimInfoInput","dimensionInfo","SeriesDimensionDefine","name","dimensionName","coordDim","coordDimIndex","otherDims","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","getDimension","_recognizeDimIndex","sourceDimDef","getSourceDimension","_getDimInfo","getSourceDimensionIndex","_getStoreDimIndex","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","mapDimension","dimensionsSummary","encodeFirstDimNotExtra","encode","mapDimensionsAll","_store","nameList","_this","isSourceInstance","DefaultDataProvider","_nameRepeatCount","_doInit","summarizeDimensions","userOutput","names","_a","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","SOURCE_FORMAT_TYPED_ARRAY","idList","isFormatOriginal","SOURCE_FORMAT_ORIGINAL","pure","sharedDataItem","isDataItemOption","convertOptionIdName","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","setCalculationInfo","_getCategory","ordinal","hasValue","dataDimIndicesOnCoord","indexOfName","rawIndexOf","invertedIndices","ctx","fCtx","dimIndices","innerRange","mapArray","result","arguments","ctxCompat","list","Model","ecModel","otherList","thisList","visual","kvObj","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","clearAllVisual","clearItemLayouts","setItemGraphicEl","el","seriesIndex","setCommonECData","dataType","eachItemGraphicEl","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","propName","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt","SourceImpl","fields","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","seriesLayoutBy","SERIES_LAYOUT_BY_COLUMN","startIndex","dimensionsDetectedCount","metaRawOption","dimensionsDefine","guessOrdinal","BE_ORDINAL","createSource","sourceData","thisMetaRawOption","detectSourceFormat","determined","determineSourceDimensions","sourceHeader","createSourceFromSeriesDataOption","isTypedArray","cloneSourceShallow","isArray","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","hasOwn","isArrayLike","normalizeDimensionsOption","dataArrayRows","arrayRowsTravelFirst","isNumber","SERIES_LAYOUT_BY_ROW","objectRowsCollectDimensions","colArr","value0","getDataItemValue","firstIndex","nameMap","rawItem","displayName","exist","maxLoop","TreeNode","hostTree","depth","height","children","viewChildren","isExpand","isRemoved","options","order","suppressVisitSub","attr","updateDepthAndHeight","child","contains","getAncestors","includeSelf","ancestors","parentNode","reverse","getAncestorsIndices","currNode","getDescendantIndices","childNode","getLevelModel","levelModels","getChildIndex","isAncestorOf","parent","isDescendantOf","Tree","_nodes","root","getNodeByDataIndex","clearLayouts","createTree","dataRoot","beforeLink","tree","listData","dimMax","buildHierarchy","dataNode","addChild","prepareSeriesDataSchema","coordDimensions","dimensionsCount","linkSeriesData","mainData","struct","structAttr"],"sourceRoot":""}