{"version":3,"file":"js/chunk-vendors-b8e726d7-legacy.f338644a.js","mappings":"2HA2CA,SAASA,EAAwBC,GAC/B,OAAqC,MAA9BA,EAAqC,EAAIA,EAA2BC,QAAU,CACvF,CAEA,SAASC,EAAiBC,GACxB,OAAOA,CACT,CAEA,IAAIC,EAEJ,WAIE,SAASA,EAAWC,EAAQC,EAAQC,EAAcC,EAAcC,EAChEC,GACEC,KAAKC,KAAOP,EACZM,KAAKE,KAAOP,EACZK,KAAKG,cAAgBP,GAAgBL,EACrCS,KAAKI,cAAgBP,GAAgBN,EAErCS,KAAKF,QAAUA,EACfE,KAAKK,kBAAiC,aAAbN,CAC3B,CA+NA,OAzNAN,EAAWa,UAAUC,IAAM,SAAUC,GAEnC,OADAR,KAAKS,KAAOD,EACLR,IACT,EAMAP,EAAWa,UAAUI,OAAS,SAAUF,GAEtC,OADAR,KAAKW,QAAUH,EACRR,IACT,EAMAP,EAAWa,UAAUM,gBAAkB,SAAUJ,GAE/C,OADAR,KAAKa,iBAAmBL,EACjBR,IACT,EAMAP,EAAWa,UAAUQ,gBAAkB,SAAUN,GAE/C,OADAR,KAAKe,iBAAmBP,EACjBR,IACT,EAMAP,EAAWa,UAAUU,iBAAmB,SAAUR,GAEhD,OADAR,KAAKiB,kBAAoBT,EAClBR,IACT,EAMAP,EAAWa,UAAUY,OAAS,SAAUV,GAEtC,OADAR,KAAKmB,QAAUX,EACRR,IACT,EAEAP,EAAWa,UAAUc,QAAU,WAC7BpB,KAAKA,KAAKK,kBAAoB,mBAAqB,qBACrD,EAEAZ,EAAWa,UAAUe,iBAAmB,WACtC,IAAI3B,EAASM,KAAKC,KACdN,EAASK,KAAKE,KACdoB,EAAkB,CAAC,EACnBC,EAAgB,IAAIC,MAAM9B,EAAOJ,QACjCmC,EAAgB,IAAID,MAAM7B,EAAOL,QAErCU,KAAK0B,cAAchC,EAAQ,KAAM6B,EAAe,iBAEhDvB,KAAK0B,cAAc/B,EAAQ2B,EAAiBG,EAAe,iBAE3D,IAAK,IAAIE,EAAI,EAAGA,EAAIjC,EAAOJ,OAAQqC,IAAK,CACtC,IAAIC,EAASL,EAAcI,GACvBE,EAAeP,EAAgBM,GAC/BE,EAAkB1C,EAAwByC,GAE9C,GAAIC,EAAkB,EAAG,CAGvB,IAAIC,EAASF,EAAaG,QAEE,IAAxBH,EAAavC,SACfgC,EAAgBM,GAAUC,EAAa,IAGzC7B,KAAKW,SAAWX,KAAKW,QAAQoB,EAAQJ,EACvC,MAA+B,IAApBG,GACTR,EAAgBM,GAAU,KAC1B5B,KAAKW,SAAWX,KAAKW,QAAQkB,EAAcF,IAE3C3B,KAAKmB,SAAWnB,KAAKmB,QAAQQ,EAEjC,CAEA3B,KAAKiC,gBAAgBR,EAAeH,EACtC,EA4BA7B,EAAWa,UAAU4B,iBAAmB,WACtC,IAAIxC,EAASM,KAAKC,KACdN,EAASK,KAAKE,KACdiC,EAAkB,CAAC,EACnBb,EAAkB,CAAC,EACnBC,EAAgB,GAChBE,EAAgB,GAEpBzB,KAAK0B,cAAchC,EAAQyC,EAAiBZ,EAAe,iBAE3DvB,KAAK0B,cAAc/B,EAAQ2B,EAAiBG,EAAe,iBAE3D,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAcjC,OAAQqC,IAAK,CAC7C,IAAIC,EAASL,EAAcI,GACvBS,EAAeD,EAAgBP,GAC/BC,EAAeP,EAAgBM,GAC/BS,EAAkBjD,EAAwBgD,GAC1CN,EAAkB1C,EAAwByC,GAE9C,GAAIQ,EAAkB,GAAyB,IAApBP,EACzB9B,KAAKa,kBAAoBb,KAAKa,iBAAiBgB,EAAcO,GAC7Dd,EAAgBM,GAAU,UACrB,GAAwB,IAApBS,GAAyBP,EAAkB,EACpD9B,KAAKe,kBAAoBf,KAAKe,iBAAiBc,EAAcO,GAC7Dd,EAAgBM,GAAU,UACrB,GAAwB,IAApBS,GAA6C,IAApBP,EAClC9B,KAAKW,SAAWX,KAAKW,QAAQkB,EAAcO,GAC3Cd,EAAgBM,GAAU,UACrB,GAAIS,EAAkB,GAAKP,EAAkB,EAClD9B,KAAKiB,mBAAqBjB,KAAKiB,kBAAkBY,EAAcO,GAC/Dd,EAAgBM,GAAU,UACrB,GAAIS,EAAkB,EAC3B,IAAK,IAAIC,EAAM,EAAGA,EAAMD,EAAiBC,IACvCtC,KAAKmB,SAAWnB,KAAKmB,QAAQiB,EAAaE,SAG5CtC,KAAKmB,SAAWnB,KAAKmB,QAAQiB,EAEjC,CAEApC,KAAKiC,gBAAgBR,EAAeH,EACtC,EAEA7B,EAAWa,UAAU2B,gBAAkB,SAAUR,EAAeH,GAC9D,IAAK,IAAIK,EAAI,EAAGA,EAAIF,EAAcnC,OAAQqC,IAAK,CAC7C,IAAIY,EAASd,EAAcE,GACvBE,EAAeP,EAAgBiB,GAC/BC,EAAepD,EAAwByC,GAE3C,GAAIW,EAAe,EACjB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAcC,IAChCzC,KAAKS,MAAQT,KAAKS,KAAKoB,EAAaY,SAEZ,IAAjBD,GACTxC,KAAKS,MAAQT,KAAKS,KAAKoB,GAIzBP,EAAgBiB,GAAU,IAC5B,CACF,EAEA9C,EAAWa,UAAUoB,cAAgB,SAAUgB,EAC/CC,EAGAC,EAAQC,GAGN,IAFA,IAAIC,EAAiB9C,KAAKK,kBAEjBsB,EAAI,EAAGA,EAAIe,EAAIpD,OAAQqC,IAAK,CAEnC,IAAIoB,EAAM,OAAS/C,KAAK6C,GAAeH,EAAIf,GAAIA,GAM/C,GAJKmB,IACHF,EAAOjB,GAAKoB,GAGTJ,EAAL,CAIA,IAAIK,EAAYL,EAAII,GAChBP,EAAepD,EAAwB4D,GAEtB,IAAjBR,GAGFG,EAAII,GAAOpB,EAEPmB,GACFF,EAAOK,KAAKF,IAEY,IAAjBP,EACTG,EAAII,GAAO,CAACC,EAAWrB,GAEvBqB,EAAUC,KAAKtB,EAhBjB,CAkBF,CACF,EAEOlC,CACT,CA7OA,GA+OA,Q,6DC1LIyD,E,iZArBAC,EAAY,YAKLC,GAA0C,qBAAhBC,YAA8B,aAAc,OAAQA,gBAAkBF,EAAY3B,MAAQ6B,YACpHC,GAA0C,qBAAhBC,YAA8B,aAAc,OAAQA,gBAAkBJ,EAAY3B,MAAQ+B,YACpHC,GAAwC,qBAAfC,WAA6B,aAAc,OAAQA,eAAiBN,EAAY3B,MAAQiC,WACjHC,GAA4C,qBAAjBC,aAA+B,aAAc,OAAQA,iBAAmBR,EAAY3B,MAAQmC,aAK9HC,EAAY,CACd,MAASF,EACT,IAAOF,EAEP,QAAWhC,MACX,OAAUA,MACV,KAAQkC,GAGV,SAASG,EAAeC,GAEtB,OAAOA,EAAW,MAAQV,EAAkBE,CAC9C,CAEA,SAASS,IACP,MAAO,CAACC,KAAWA,IACrB,CAEA,SAASC,EAAWC,GAClB,IAAIC,EAAOD,EAAcE,YAEzB,OAAOD,IAAS3C,MAAQ0C,EAAcG,QAAU,IAAIF,EAAKD,EAC3D,CACA,SAASI,EAAaC,EAAOC,EAAQC,EAASC,EAAKC,GACjD,IAAIC,EAAWhB,EAAUa,GAAW,SACpC,GAAIE,EAAQ,CACV,IAAIE,EAAWN,EAAMC,GACjBM,EAASD,GAAYA,EAASvF,OAClC,GAAMwF,IAAWJ,EAAM,CAIrB,IAHA,IAAIK,EAAW,IAAIH,EAASF,GAGnBjC,EAAI,EAAGA,EAAIqC,EAAQrC,IAC1BsC,EAAStC,GAAKoC,EAASpC,GAEzB8B,EAAMC,GAAUO,CAClB,CACF,MACER,EAAMC,GAAU,IAAII,EAASF,EAEjC,CAMA,IAAIM,EACJ,WACE,SAASA,IACPhF,KAAKiF,QAAU,GAEfjF,KAAKkF,WAAa,GAClBlF,KAAKmF,QAAU,GACfnF,KAAKoF,OAAS,EACdpF,KAAKqF,UAAY,EACjBrF,KAAKsF,mBAAoB,IAAAC,gBAC3B,CA44BA,OAv4BAP,EAAU1E,UAAUkF,SAAW,SAAUC,EAAUC,EAAiBC,GAIlE3F,KAAK4F,UAAYH,EAEjBzF,KAAKiF,QAAU,GACfjF,KAAK6F,SAAW,KAChB7F,KAAK8F,YAAc9F,KAAK+F,mBACxB,IAAIC,EAASP,EAASQ,YAClBC,EAAgBlG,KAAKmG,sBAAwBjD,EAAuB8C,EAAOI,cAE/EpG,KAAKqG,gBAAkBV,GAAkBO,EAEzClG,KAAKkF,WAAa,IACW,QAAyBc,GACtDhG,KAAKsG,aAAc,IAAA3D,KAAI+C,GAAiB,SAAUa,GAMhD,MAAO,CAELC,KAAMD,EAAIC,KACVC,SAAUF,EAAIE,SAElB,IACAzG,KAAK0G,sBAAsB,EAAGjB,EAASkB,QACzC,EACA3B,EAAU1E,UAAUsG,YAAc,WAChC,OAAO5G,KAAK4F,SACd,EASAZ,EAAU1E,UAAU2F,UAAY,WAC9B,OAAOjG,KAAK4F,UAAUK,WACxB,EAKAjB,EAAU1E,UAAUuG,2BAA6B,SAAUC,EAASN,GAClE,IAAIO,EAAmB/G,KAAKsF,kBACxB0B,EAAahH,KAAKsG,YAClBW,EAAaF,EAAiBG,IAAIJ,GACtC,GAAkB,MAAdG,GACF,GAAID,EAAWC,GAAYT,OAASA,EAClC,OAAOS,OAGTA,EAAaD,EAAW1H,OAQ1B,OANA0H,EAAWC,GAAc,CACvBT,KAAMA,GAERO,EAAiBI,IAAIL,EAASG,GAC9BjH,KAAKiF,QAAQgC,GAAc,IAAIrD,EAAU4C,GAAQ,SAASxG,KAAKqF,WAC/DrF,KAAKkF,WAAW+B,GAAclD,IACvBkD,CACT,EACAjC,EAAU1E,UAAU8G,mBAAqB,SAAU5C,EAAQ6C,GACzD,IAAIC,EAAQtH,KAAKiF,QAAQT,GACrB+B,EAAMvG,KAAKsG,YAAY9B,GACvB+C,EAAavH,KAAKkF,WAClBsC,EAASjB,EAAIkB,eAAiB,EAC9BC,EAAMJ,EAAMhI,OACD,IAAXkI,IAGFD,EAAW/C,GAAUT,KAIvB,IAFA,IAAI4D,EAAeJ,EAAW/C,GAErB7C,EAAI6F,EAAQ7F,EAAI+F,EAAK/F,IAAK,CACjC,IAAIiG,EAAMN,EAAM3F,GAAK0F,EAAYQ,gBAAgBP,EAAM3F,IAClDmG,MAAMF,KACTD,EAAa,GAAKI,KAAKC,IAAIJ,EAAKD,EAAa,IAC7CA,EAAa,GAAKI,KAAKE,IAAIL,EAAKD,EAAa,IAEjD,CACApB,EAAIc,YAAcA,EAClBd,EAAIkB,cAAgBC,EACpBnB,EAAIC,KAAO,SACb,EAEAxB,EAAU1E,UAAU4H,eAAiB,SAAU1D,GAC7C,IAAI2D,EAAUnI,KAAKsG,YAAY9B,GAC3B6C,EAAcc,EAAQd,YAC1B,OAAOA,CACT,EACArC,EAAU1E,UAAU8H,qBAAuB,SAAUC,GACnD,IAAI7I,EAAOQ,KAAKsG,YAAY+B,GAC5B,OAAO7I,GAAQA,EAAKiH,QACtB,EAKAzB,EAAU1E,UAAUgI,WAAa,SAAUC,GAIzC,IAAI9C,EAAWzF,KAAK4F,UAChB4C,EAAQxI,KAAK2G,QACjBlB,EAAS6C,WAAWC,GACpB,IAAI7D,EAAMe,EAASkB,QAOnB,OANKlB,EAASgD,aACZ/D,GAAO8D,GAELA,EAAQ9D,GACV1E,KAAK0G,sBAAsB8B,EAAO9D,GAAK,GAElC,CAAC8D,EAAO9D,EACjB,EACAM,EAAU1E,UAAUoI,aAAe,SAAUC,EAAQC,GAOnD,IANA,IAAIC,EAAS7I,KAAKiF,QACd+B,EAAahH,KAAKsG,YAClBwC,EAAS9B,EAAW1H,OACpByJ,EAAY/I,KAAKkF,WACjBsD,EAAQxI,KAAK2G,QACbjC,EAAM8D,EAAQT,KAAKE,IAAIU,EAAOrJ,OAAQsJ,GAAc,GAC/CjH,EAAI,EAAGA,EAAImH,EAAQnH,IAAK,CAC/B,IAAI4E,EAAMS,EAAWrF,GACrB2C,EAAauE,EAAQlH,EAAG4E,EAAIC,KAAM9B,GAAK,EACzC,CAEA,IADA,IAAIsE,EAAgB,GACXC,EAAMT,EAAOS,EAAMvE,EAAKuE,IAG/B,IAFA,IAAIC,EAAYD,EAAMT,EAEbhE,EAAS,EAAGA,EAASsE,EAAQtE,IAAU,CAC1C+B,EAAMS,EAAWxC,GAArB,IACIoD,EAAM1E,EAAuBiG,UAAUC,KAAKpJ,KAAM2I,EAAOO,IAAcF,EAAezC,EAAIE,SAAUyC,EAAW1E,GACnHqE,EAAOrE,GAAQyE,GAAOrB,EACtB,IAAID,EAAeoB,EAAUvE,GAC7BoD,EAAMD,EAAa,KAAOA,EAAa,GAAKC,GAC5CA,EAAMD,EAAa,KAAOA,EAAa,GAAKC,EAC9C,CAGF,OADA5H,KAAKqF,UAAYrF,KAAKoF,OAASV,EACxB,CACL8D,MAAOA,EACP9D,IAAKA,EAET,EACAM,EAAU1E,UAAUoG,sBAAwB,SAAU8B,EAAO9D,EAAKC,GAShE,IARA,IAAIc,EAAWzF,KAAK4F,UAChBiD,EAAS7I,KAAKiF,QACd+B,EAAahH,KAAKsG,YAClBwC,EAAS9B,EAAW1H,OACpByJ,EAAY/I,KAAKkF,WACjBmE,GAAW,IAAA1G,KAAIqE,GAAY,SAAUT,GACvC,OAAOA,EAAIE,QACb,IACS9E,EAAI,EAAGA,EAAImH,EAAQnH,IAAK,CAC/B,IAAI4E,EAAMS,EAAWrF,GAChBoH,EAAUpH,KACboH,EAAUpH,GAAKoC,KAEjBO,EAAauE,EAAQlH,EAAG4E,EAAIC,KAAM9B,EAAKC,EACzC,CACA,GAAIc,EAAS6D,YACX7D,EAAS6D,YAAYd,EAAO9D,EAAKmE,EAAQE,QAGzC,IADA,IAAIQ,EAAW,GACNN,EAAMT,EAAOS,EAAMvE,EAAKuE,IAAO,CAEtCM,EAAW9D,EAAS+D,QAAQP,EAAKM,GAQjC,IAAK,IAAI/E,EAAS,EAAGA,EAASsE,EAAQtE,IAAU,CAC9C,IAAIiF,EAAaZ,EAAOrE,GAEpBoD,EAAM5H,KAAKqG,gBAAgBkD,EAAUF,EAAS7E,GAASyE,EAAKzE,GAChEiF,EAAWR,GAAOrB,EAClB,IAAID,EAAeoB,EAAUvE,GAC7BoD,EAAMD,EAAa,KAAOA,EAAa,GAAKC,GAC5CA,EAAMD,EAAa,KAAOA,EAAa,GAAKC,EAC9C,CACF,EAEGnC,EAASgD,YAAchD,EAASiE,OAEnCjE,EAASiE,QAEX1J,KAAKqF,UAAYrF,KAAKoF,OAASV,EAE/B1E,KAAKmF,QAAU,EACjB,EACAH,EAAU1E,UAAUqG,MAAQ,WAC1B,OAAO3G,KAAKoF,MACd,EAKAJ,EAAU1E,UAAU4G,IAAM,SAAUX,EAAK0C,GACvC,KAAMA,GAAO,GAAKA,EAAMjJ,KAAKoF,QAC3B,OAAOuE,IAET,IAAIC,EAAW5J,KAAKiF,QAAQsB,GAC5B,OAAOqD,EAAWA,EAAS5J,KAAK8F,YAAYmD,IAAQU,GACtD,EACA3E,EAAU1E,UAAUuJ,UAAY,SAAU7C,EAAYiC,GACpD,IAAIN,EAAS,GACTmB,EAAS,GACb,GAAW,MAAPb,EAAa,CACfA,EAAMjC,EAENA,EAAa,GAEb,IAAK,IAAIrF,EAAI,EAAGA,EAAI3B,KAAKsG,YAAYhH,OAAQqC,IAC3CmI,EAAO7G,KAAKtB,EAEhB,MACEmI,EAAS9C,EAEFrF,EAAI,EAAb,IAAK,IAAW+F,EAAMoC,EAAOxK,OAAQqC,EAAI+F,EAAK/F,IAC5CgH,EAAO1F,KAAKjD,KAAKkH,IAAI4C,EAAOnI,GAAIsH,IAElC,OAAON,CACT,EAKA3D,EAAU1E,UAAUyJ,cAAgB,SAAUxD,EAAKyD,GACjD,KAAMA,GAAU,GAAKA,EAAShK,KAAKqF,WACjC,OAAOsE,IAET,IAAIC,EAAW5J,KAAKiF,QAAQsB,GAC5B,OAAOqD,EAAWA,EAASI,GAAUL,GACvC,EAKA3E,EAAU1E,UAAU2J,OAAS,SAAU1D,GACrC,IAAI2D,EAAUlK,KAAKiF,QAAQsB,GACvB4D,EAAM,EACV,GAAID,EACF,IAAK,IAAIvI,EAAI,EAAG+F,EAAM1H,KAAK2G,QAAShF,EAAI+F,EAAK/F,IAAK,CAChD,IAAIyI,EAAQpK,KAAKkH,IAAIX,EAAK5E,GACrBmG,MAAMsC,KACTD,GAAOC,EAEX,CAEF,OAAOD,CACT,EAKAnF,EAAU1E,UAAU+J,UAAY,SAAU9D,GACxC,IAAI+D,EAAe,GAEnBtK,KAAKuK,KAAK,CAAChE,IAAM,SAAUqB,GACpBE,MAAMF,IACT0C,EAAarH,KAAK2E,EAEtB,IAGA,IAAI4C,EAAqBF,EAAaG,MAAK,SAAUC,EAAGC,GACtD,OAAOD,EAAIC,CACb,IACIjD,EAAM1H,KAAK2G,QAEf,OAAe,IAARe,EAAY,EAAIA,EAAM,IAAM,EAAI8C,GAAoB9C,EAAM,GAAK,IAAM8C,EAAmB9C,EAAM,GAAK8C,EAAmB9C,EAAM,EAAI,IAAM,CAC/I,EAKA1C,EAAU1E,UAAUsK,gBAAkB,SAAUC,GAC9C,GAAIA,GAAY7K,KAAKqF,WAAawF,EAAW,EAC3C,OAAQ,EAEV,IAAK7K,KAAK6F,SACR,OAAOgF,EAGT,IAAIC,EAAU9K,KAAK6F,SAEfkF,EAAeD,EAAQD,GAC3B,GAAoB,MAAhBE,GAAwBA,EAAe/K,KAAKoF,QAAU2F,IAAiBF,EACzE,OAAOA,EAET,IAAIG,EAAO,EACPC,EAAQjL,KAAKoF,OAAS,EAC1B,MAAO4F,GAAQC,EAAO,CACpB,IAAIC,GAAOF,EAAOC,GAAS,EAAI,EAC/B,GAAIH,EAAQI,GAAOL,EACjBG,EAAOE,EAAM,MACR,MAAIJ,EAAQI,GAAOL,GAGxB,OAAOK,EAFPD,EAAQC,EAAM,CAGhB,CACF,CACA,OAAQ,CACV,EAUAlG,EAAU1E,UAAU6K,iBAAmB,SAAU5E,EAAK6D,EAAOgB,GAC3D,IAAIvC,EAAS7I,KAAKiF,QACdiF,EAAUrB,EAAOtC,GACjB8E,EAAiB,GACrB,IAAKnB,EACH,OAAOmB,EAEU,MAAfD,IACFA,EAAcpH,KAMhB,IAJA,IAAIsH,EAAUtH,IACVuH,GAAW,EACXC,EAAoB,EAEf7J,EAAI,EAAG+F,EAAM1H,KAAK2G,QAAShF,EAAI+F,EAAK/F,IAAK,CAChD,IAAI8J,EAAYzL,KAAK8F,YAAYnE,GAC7B+J,EAAOtB,EAAQF,EAAQuB,GACvBE,EAAO5D,KAAK6D,IAAIF,GAChBC,GAAQP,KAONO,EAAOL,GAAWK,IAASL,GAAWI,GAAQ,GAAKH,EAAU,KAC/DD,EAAUK,EACVJ,EAAUG,EACVF,EAAoB,GAElBE,IAASH,IACXF,EAAeG,KAAuB7J,GAG5C,CAEA,OADA0J,EAAe/L,OAASkM,EACjBH,CACT,EACArG,EAAU1E,UAAUuL,WAAa,WAC/B,IAAIC,EACAhB,EAAU9K,KAAK6F,SACnB,GAAIiF,EAAS,CACX,IAAI3G,EAAO2G,EAAQ1G,YACf2H,EAAY/L,KAAKoF,OAErB,GAAIjB,IAAS3C,MAAO,CAClBsK,EAAa,IAAI3H,EAAK4H,GACtB,IAAK,IAAIpK,EAAI,EAAGA,EAAIoK,EAAWpK,IAC7BmK,EAAWnK,GAAKmJ,EAAQnJ,EAE5B,MACEmK,EAAa,IAAI3H,EAAK2G,EAAQkB,OAAQ,EAAGD,EAE7C,KAAO,CACD5H,EAAON,EAAe7D,KAAKqF,WAC/ByG,EAAa,IAAI3H,EAAKnE,KAAK2G,SAC3B,IAAShF,EAAI,EAAGA,EAAImK,EAAWxM,OAAQqC,IACrCmK,EAAWnK,GAAKA,CAEpB,CACA,OAAOmK,CACT,EAKA9G,EAAU1E,UAAU2L,OAAS,SAAUC,EAAMC,GAC3C,IAAKnM,KAAKoF,OACR,OAAOpF,KAWT,IATA,IAAI+E,EAAW/E,KAAKoM,QAChBzF,EAAQ5B,EAAS4B,QACjBxC,EAAON,EAAekB,EAASM,WAC/ByG,EAAa,IAAI3H,EAAKwC,GACtByD,EAAQ,GACRiC,EAAUH,EAAK5M,OACfkI,EAAS,EACT8E,EAAOJ,EAAK,GACZrD,EAAS9D,EAASE,QACbtD,EAAI,EAAGA,EAAIgF,EAAOhF,IAAK,CAC9B,IAAI4K,OAAO,EACPvC,EAASjF,EAASe,YAAYnE,GAElC,GAAgB,IAAZ0K,EACFE,EAAOJ,EAAGxK,QACL,GAAgB,IAAZ0K,EAAe,CACxB,IAAIzE,EAAMiB,EAAOyD,GAAMtC,GACvBuC,EAAOJ,EAAGvE,EAAKjG,EACjB,KAAO,CAEL,IADA,IAAI6K,EAAI,EACDA,EAAIH,EAASG,IAClBpC,EAAMoC,GAAK3D,EAAOqD,EAAKM,IAAIxC,GAE7BI,EAAMoC,GAAK7K,EACX4K,EAAOJ,EAAGM,MAAM,KAAMrC,EACxB,CACImC,IACFT,EAAWtE,KAAYwC,EAE3B,CASA,OAPIxC,EAASb,IACX5B,EAASc,SAAWiG,GAEtB/G,EAASK,OAASoC,EAElBzC,EAASI,QAAU,GACnBJ,EAAS2H,mBACF3H,CACT,EAMAC,EAAU1E,UAAUqM,YAAc,SAAUC,GAC1C,IAAI7H,EAAW/E,KAAKoM,QAChB1E,EAAM3C,EAASK,OACnB,IAAKsC,EACH,OAAO1H,KAET,IAAIkM,GAAO,IAAAW,MAAKD,GACZP,EAAUH,EAAK5M,OACnB,IAAK+M,EACH,OAAOrM,KAET,IAAI8M,EAAgB/H,EAAS4B,QACzBxC,EAAON,EAAekB,EAASM,WAC/ByG,EAAa,IAAI3H,EAAK2I,GACtBtF,EAAS,EACT8E,EAAOJ,EAAK,GACZlE,EAAM4E,EAAMN,GAAM,GAClBrE,EAAM2E,EAAMN,GAAM,GAClBS,EAAWhI,EAASE,QACpB+H,GAAgB,EACpB,IAAKjI,EAASc,SAAU,CAEtB,IAAIoD,EAAM,EACV,GAAgB,IAAZoD,EAAe,CAEjB,IADA,IAAI5C,EAAasD,EAASb,EAAK,IACtBvK,EAAI,EAAGA,EAAI+F,EAAK/F,IAAK,CAC5B,IAAIiG,EAAM6B,EAAW9H,IAMjBiG,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MACpCkE,EAAWtE,KAAYyB,GAEzBA,GACF,CACA+D,GAAgB,CAClB,MAAO,GAAgB,IAAZX,EAAe,CACpB5C,EAAasD,EAASb,EAAK,IAA/B,IACIe,EAAcF,EAASb,EAAK,IAC5BgB,EAAON,EAAMV,EAAK,IAAI,GACtBiB,EAAOP,EAAMV,EAAK,IAAI,GAC1B,IAASvK,EAAI,EAAGA,EAAI+F,EAAK/F,IAAK,CACxBiG,EAAM6B,EAAW9H,GAArB,IACIyL,EAAOH,EAAYtL,IAElBiG,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MAAUwF,GAAQF,GAAQE,GAAQD,GAAQrF,MAAMsF,MACrFtB,EAAWtE,KAAYyB,GAEzBA,GACF,CACA+D,GAAgB,CAClB,CACF,CACA,IAAKA,EACH,GAAgB,IAAZX,EACF,IAAS1K,EAAI,EAAGA,EAAImL,EAAenL,IAAK,CACtC,IAAIkJ,EAAW9F,EAASe,YAAYnE,GAChCiG,EAAMmF,EAASb,EAAK,IAAIrB,IAExBjD,GAAOI,GAAOJ,GAAOK,GAAOH,MAAMF,MACpCkE,EAAWtE,KAAYqD,EAE3B,MAEA,IAASlJ,EAAI,EAAGA,EAAImL,EAAenL,IAAK,CAGtC,IAFA,IAAI4K,GAAO,EAEFC,GADL3B,EAAW9F,EAASe,YAAYnE,GACvB,GAAG6K,EAAIH,EAASG,IAAK,CAChC,IAAIa,EAAOnB,EAAKM,GACZ5E,EAAMmF,EAASM,GAAMxC,IAErBjD,EAAMgF,EAAMS,GAAM,IAAMzF,EAAMgF,EAAMS,GAAM,MAC5Cd,GAAO,EAEX,CACIA,IACFT,EAAWtE,KAAYzC,EAASe,YAAYnE,GAEhD,CAWJ,OAPI6F,EAASsF,IACX/H,EAASc,SAAWiG,GAEtB/G,EAASK,OAASoC,EAElBzC,EAASI,QAAU,GACnBJ,EAAS2H,mBACF3H,CACT,EAeAC,EAAU1E,UAAUqC,IAAM,SAAUuJ,EAAMC,GAExC,IAAImB,EAAStN,KAAKoM,MAAMF,GAExB,OADAlM,KAAKuN,YAAYD,EAAQpB,EAAMC,GACxBmB,CACT,EAKAtI,EAAU1E,UAAUkN,OAAS,SAAUtB,EAAMC,GAC3CnM,KAAKuN,YAAYvN,KAAMkM,EAAMC,EAC/B,EACAnH,EAAU1E,UAAUiN,YAAc,SAAUD,EAAQpB,EAAMC,GAOxD,IANA,IAAIsB,EAAeH,EAAOrI,QACtByI,EAAc,GACdrB,EAAUH,EAAK5M,OACfqO,EAAYL,EAAO3G,QACnBgC,EAAS,GACTI,EAAYuE,EAAOpI,WACdvD,EAAI,EAAGA,EAAIuK,EAAK5M,OAAQqC,IAC/BoH,EAAUmD,EAAKvK,IAAMoC,IAEvB,IAAK,IAAI0H,EAAY,EAAGA,EAAYkC,EAAWlC,IAAa,CAE1D,IADA,IAAIZ,EAAWyC,EAAOxH,YAAY2F,GACzBe,EAAI,EAAGA,EAAIH,EAASG,IAC3B7D,EAAO6D,GAAKiB,EAAavB,EAAKM,IAAI3B,GAEpClC,EAAO0D,GAAWZ,EAClB,IAAImC,EAAWzB,GAAMA,EAAGM,MAAM,KAAM9D,GACpC,GAAgB,MAAZiF,EAAkB,CAEM,YAAtB,OAAQA,KACVF,EAAY,GAAKE,EACjBA,EAAWF,GAEb,IAAS/L,EAAI,EAAGA,EAAIiM,EAAStO,OAAQqC,IAAK,CACxC,IAAI4E,EAAM2F,EAAKvK,GACXiG,EAAMgG,EAASjM,GACfkM,EAAiB9E,EAAUxC,GAC3BqD,EAAW6D,EAAalH,GACxBqD,IACFA,EAASiB,GAAYjD,GAEnBA,EAAMiG,EAAe,KACvBA,EAAe,GAAKjG,GAElBA,EAAMiG,EAAe,KACvBA,EAAe,GAAKjG,EAExB,CACF,CACF,CACF,EAOA5C,EAAU1E,UAAUwN,eAAiB,SAAUC,EAAgBC,GAC7D,IAOIC,EACAC,EACAC,EATAb,EAAStN,KAAKoM,MAAM,CAAC2B,IAAiB,GACtCK,EAAgBd,EAAOrI,QACvB2E,EAAWwE,EAAcL,GACzBrG,EAAM1H,KAAK2G,QACX0H,EAAe,EACfC,EAAYvG,KAAKwG,MAAM,EAAIP,GAC3BQ,EAAkBxO,KAAK8F,YAAY,GAInCgG,EAAa,IAAKjI,EAAe7D,KAAKqF,WAAzB,CAAqC0C,KAAKC,IAAuC,GAAlCD,KAAK0G,KAAK/G,EAAM4G,GAAa,GAAQ5G,IAErGoE,EAAWuC,KAAkBG,EAC7B,IAAK,IAAI7M,EAAI,EAAGA,EAAI+F,EAAM,EAAG/F,GAAK2M,EAAW,CAK3C,IAJA,IAAII,EAAiB3G,KAAKC,IAAIrG,EAAI2M,EAAW5G,EAAM,GAC/CiH,EAAe5G,KAAKC,IAAIrG,EAAgB,EAAZ2M,EAAe5G,GAC3CkH,GAAQD,EAAeD,GAAkB,EACzCG,EAAO,EACF5F,EAAMyF,EAAgBzF,EAAM0F,EAAc1F,IAAO,CACxD,IAAI4B,EAAW7K,KAAK8F,YAAYmD,GAC5B6F,EAAIlF,EAASiB,GACb/C,MAAMgH,KAGVD,GAAQC,EACV,CACAD,GAAQF,EAAeD,EACvB,IAAIK,EAAapN,EACbqN,EAAWjH,KAAKC,IAAIrG,EAAI2M,EAAW5G,GACnCuH,EAAUtN,EAAI,EACduN,EAAUtF,EAAS4E,GACvBP,GAAW,EACXE,EAAeY,EACf,IAAII,GAAiB,EACjBC,EAAW,EAGf,IAASnG,EAAM8F,EAAY9F,EAAM+F,EAAU/F,IAAO,CAC5C4B,EAAW7K,KAAK8F,YAAYmD,GAC5B6F,EAAIlF,EAASiB,GACb/C,MAAMgH,IACRM,IACID,EAAgB,IAClBA,EAAgBtE,KAKpBqD,EAAOnG,KAAK6D,KAAKqD,EAAUL,IAASE,EAAII,IAAYD,EAAUhG,IAAQ4F,EAAOK,IACzEhB,EAAOD,IACTA,EAAUC,EACVC,EAAetD,GAEnB,CAEIuE,EAAW,GAAKA,EAAWJ,EAAWD,IAGxCjD,EAAWuC,KAAkBtG,KAAKC,IAAImH,EAAehB,GACrDA,EAAepG,KAAKE,IAAIkH,EAAehB,IAEzCrC,EAAWuC,KAAkBF,EAC7BK,EAAkBL,CACpB,CAMA,OAJArC,EAAWuC,KAAkBrO,KAAK8F,YAAY4B,EAAM,GACpD4F,EAAOlI,OAASiJ,EAChBf,EAAOzH,SAAWiG,EAClBwB,EAAOxH,YAAc9F,KAAKqP,WACnB/B,CACT,EAMAtI,EAAU1E,UAAUgP,WAAa,SAAUC,EAAWvB,EAAMwB,EAAaC,GAUvE,IATA,IAAInC,EAAStN,KAAKoM,MAAM,CAACmD,IAAY,GACjCnB,EAAgBd,EAAOrI,QACvByK,EAAc,GACdpB,EAAYvG,KAAKwG,MAAM,EAAIP,GAC3BpE,EAAWwE,EAAcmB,GACzB7H,EAAM1H,KAAK2G,QACXkH,EAAiBP,EAAOpI,WAAWqK,GAAaxL,IAChD+H,EAAa,IAAKjI,EAAe7D,KAAKqF,WAAzB,CAAqC0C,KAAK0G,KAAK/G,EAAM4G,IAClE9G,EAAS,EACJ7F,EAAI,EAAGA,EAAI+F,EAAK/F,GAAK2M,EAAW,CAEnCA,EAAY5G,EAAM/F,IACpB2M,EAAY5G,EAAM/F,EAClB+N,EAAYpQ,OAASgP,GAEvB,IAAK,IAAI9B,EAAI,EAAGA,EAAI8B,EAAW9B,IAAK,CAClC,IAAImD,EAAU3P,KAAK8F,YAAYnE,EAAI6K,GACnCkD,EAAYlD,GAAK5C,EAAS+F,EAC5B,CACA,IAAIvF,EAAQoF,EAAYE,GACpBE,EAAiB5P,KAAK8F,YAAYiC,KAAKC,IAAIrG,EAAI8N,EAAYC,EAAatF,IAAU,EAAG1C,EAAM,IAE/FkC,EAASgG,GAAkBxF,EACvBA,EAAQyD,EAAe,KACzBA,EAAe,GAAKzD,GAElBA,EAAQyD,EAAe,KACzBA,EAAe,GAAKzD,GAEtB0B,EAAWtE,KAAYoI,CACzB,CAIA,OAHAtC,EAAOlI,OAASoC,EAChB8F,EAAOzH,SAAWiG,EAClBwB,EAAOZ,mBACAY,CACT,EAUAtI,EAAU1E,UAAUiK,KAAO,SAAU2B,EAAMC,GACzC,GAAKnM,KAAKoF,OAKV,IAFA,IAAIiH,EAAUH,EAAK5M,OACfuJ,EAAS7I,KAAKiF,QACTtD,EAAI,EAAG+F,EAAM1H,KAAK2G,QAAShF,EAAI+F,EAAK/F,IAAK,CAChD,IAAIqI,EAAShK,KAAK8F,YAAYnE,GAE9B,OAAQ0K,GACN,KAAK,EACHF,EAAGxK,GACH,MACF,KAAK,EACHwK,EAAGtD,EAAOqD,EAAK,IAAIlC,GAASrI,GAC5B,MACF,KAAK,EACHwK,EAAGtD,EAAOqD,EAAK,IAAIlC,GAASnB,EAAOqD,EAAK,IAAIlC,GAASrI,GACrD,MACF,QAGE,IAFA,IAAI6K,EAAI,EACJpC,EAAQ,GACLoC,EAAIH,EAASG,IAClBpC,EAAMoC,GAAK3D,EAAOqD,EAAKM,IAAIxC,GAG7BI,EAAMoC,GAAK7K,EACXwK,EAAGM,MAAM,KAAMrC,GAErB,CACF,EAKApF,EAAU1E,UAAUuP,cAAgB,SAAUtJ,GAE5C,IAAI2D,EAAUlK,KAAKiF,QAAQsB,GACvBuJ,EAAgB/L,IACpB,IAAKmG,EACH,OAAO4F,EAGT,IAKIC,EALAC,EAAUhQ,KAAK2G,QAIfsJ,GAAUjQ,KAAK6F,SAEnB,GAAIoK,EACF,OAAOjQ,KAAKkF,WAAWqB,GAAKlC,QAG9B,GADA0L,EAAY/P,KAAKmF,QAAQoB,GACrBwJ,EACF,OAAOA,EAAU1L,QAEnB0L,EAAYD,EAGZ,IAFA,IAAI9H,EAAM+H,EAAU,GAChB9H,EAAM8H,EAAU,GACXpO,EAAI,EAAGA,EAAIqO,EAASrO,IAAK,CAChC,IAAIqI,EAAShK,KAAK8F,YAAYnE,GAC1ByI,EAAQF,EAAQF,GACpBI,EAAQpC,IAAQA,EAAMoC,GACtBA,EAAQnC,IAAQA,EAAMmC,EACxB,CAGA,OAFA2F,EAAY,CAAC/H,EAAKC,GAClBjI,KAAKmF,QAAQoB,GAAOwJ,EACbA,CACT,EAKA/K,EAAU1E,UAAU4P,eAAiB,SAAUjH,GAC7C,IAAIe,EAAShK,KAAK8F,YAAYmD,GAC9B,GAAKjJ,KAAK4F,UAAU6C,WAQlB,OAAOzI,KAAK4F,UAAU4D,QAAQQ,GAL9B,IAFA,IAAIpC,EAAM,GACNiB,EAAS7I,KAAKiF,QACTtD,EAAI,EAAGA,EAAIkH,EAAOvJ,OAAQqC,IACjCiG,EAAI3E,KAAK4F,EAAOlH,GAAGqI,IAErB,OAAOpC,CAIX,EAOA5C,EAAU1E,UAAU8L,MAAQ,SAAU+D,EAAYC,GAChD,IAAI9C,EAAS,IAAItI,EACb6D,EAAS7I,KAAKiF,QACdoL,EAAgBF,IAAc,IAAAG,QAAOH,GAAY,SAAUI,EAAK/L,GAElE,OADA+L,EAAI/L,IAAU,EACP+L,CACT,GAAG,CAAC,GACJ,GAAIF,EACF,IAAK,IAAI1O,EAAI,EAAGA,EAAIkH,EAAOvJ,OAAQqC,IAEjC2L,EAAOrI,QAAQtD,GAAM0O,EAAc1O,GAAiBsC,EAAW4E,EAAOlH,IAA9BkH,EAAOlH,QAGjD2L,EAAOrI,QAAU4D,EAOnB,OALA7I,KAAKwQ,iBAAiBlD,GACjB8C,IACH9C,EAAOzH,SAAW7F,KAAKyQ,iBAEzBnD,EAAOZ,mBACAY,CACT,EACAtI,EAAU1E,UAAUkQ,iBAAmB,SAAUlD,GAC/CA,EAAOlI,OAASpF,KAAKoF,OACrBkI,EAAOjI,UAAYrF,KAAKqF,UACxBiI,EAAO1H,UAAY5F,KAAK4F,UACxB0H,EAAOhH,YAActG,KAAKsG,YAC1BgH,EAAOnI,SAAU,IAAAiH,OAAMpM,KAAKmF,SAC5BmI,EAAOpI,YAAa,IAAAkH,OAAMpM,KAAKkF,WACjC,EACAF,EAAU1E,UAAUmQ,cAAgB,WAClC,GAAIzQ,KAAK6F,SAAU,CACjB,IAAI1B,EAAOnE,KAAK6F,SAASzB,YACrB0G,OAAU,EACd,GAAI3G,IAAS3C,MAAO,CAClB,IAAIuK,EAAY/L,KAAK6F,SAASvG,OAC9BwL,EAAU,IAAI3G,EAAK4H,GACnB,IAAK,IAAIpK,EAAI,EAAGA,EAAIoK,EAAWpK,IAC7BmJ,EAAQnJ,GAAK3B,KAAK6F,SAASlE,EAE/B,MACEmJ,EAAU,IAAI3G,EAAKnE,KAAK6F,UAE1B,OAAOiF,CACT,CACA,OAAO,IACT,EACA9F,EAAU1E,UAAUyF,mBAAqB,SAAUkD,GACjD,OAAOA,CACT,EACAjE,EAAU1E,UAAU+O,WAAa,SAAUpG,GACzC,OAAIA,EAAMjJ,KAAKoF,QAAU6D,GAAO,EACvBjJ,KAAK6F,SAASoD,IAEf,CACV,EACAjE,EAAU1E,UAAUoM,iBAAmB,WACrC1M,KAAK8F,YAAc9F,KAAK6F,SAAW7F,KAAKqP,WAAarP,KAAK+F,kBAC5D,EACAf,EAAU0L,cAAgB,WACxB,SAASC,EAAkBpH,EAAU9C,EAAUgF,EAAWpD,GACxD,OAAO,QAAekB,EAASlB,GAAWrI,KAAKsG,YAAY+B,GAC7D,CACAnF,EAAyB,CACvBiG,UAAWwH,EACXC,WAAY,SAAoBrH,EAAU9C,EAAUgF,EAAWpD,GAC7D,OAAO,QAAekB,EAAS9C,GAAWzG,KAAKsG,YAAY+B,GAC7D,EACAwI,aAAcF,EACdG,SAAU,SAAkBvH,EAAU9C,EAAUgF,EAAWpD,GAKzD,IAAI+B,EAAQb,IAA+B,MAAlBA,EAASa,MAAgBb,EAAWA,EAASa,OACtE,OAAO,QAAeA,aAAiB5I,MAAQ4I,EAAM/B,GACnD+B,EAAOpK,KAAKsG,YAAY+B,GAC5B,EACA0I,WAAY,SAAoBxH,EAAU9C,EAAUgF,EAAWpD,GAC7D,OAAOkB,EAASlB,EAClB,EAEJ,CAvB0B,GAwBnBrD,CACT,CAt5BA,GAu5BA,S,gDC3/BA,SAASgM,EAAgBC,GACvB,MAAO,OAASA,CAClB,CAEA,IAAIC,EAEJ,WACE,SAASA,EAAMC,GACbnR,KAAKwG,KAAO,QACZxG,KAAKoR,MAAQ,GACbpR,KAAKqR,MAAQ,GACbrR,KAAKsR,UAAY,CAAC,EAMlBtR,KAAKuR,UAAY,CAAC,EAClBvR,KAAKwR,UAAYL,IAAY,CAC/B,CAiRA,OA3QAD,EAAM5Q,UAAUmR,WAAa,WAC3B,OAAOzR,KAAKwR,SACd,EAOAN,EAAM5Q,UAAUoR,QAAU,SAAUT,EAAIxF,GACtCwF,EAAW,MAANA,EAAa,GAAKxF,EAAY,GAAKwF,EACxC,IAAIU,EAAW3R,KAAKsR,UAEpB,IAAIK,EAASX,EAAgBC,IAA7B,CAQA,IAAIW,EAAO,IAAIC,EAAUZ,EAAIxF,GAI7B,OAHAmG,EAAKE,UAAY9R,KACjBA,KAAKoR,MAAMnO,KAAK2O,GAChBD,EAASX,EAAgBC,IAAOW,EACzBA,CANP,CAOF,EAOAV,EAAM5Q,UAAUyR,eAAiB,SAAUtG,GACzC,IAAIzB,EAAShK,KAAKuI,KAAKzC,YAAY2F,GACnC,OAAOzL,KAAKoR,MAAMpH,EACpB,EAOAkH,EAAM5Q,UAAU0R,YAAc,SAAUf,GACtC,OAAOjR,KAAKsR,UAAUN,EAAgBC,GACxC,EAOAC,EAAM5Q,UAAU2R,QAAU,SAAUC,EAAIC,EAAI1G,GAC1C,IAAIkG,EAAW3R,KAAKsR,UAChBc,EAAWpS,KAAKuR,UAkBpB,GAhBIc,EAAAA,SAAgBH,KAClBA,EAAKlS,KAAKoR,MAAMc,IAGdG,EAAAA,SAAgBF,KAClBA,EAAKnS,KAAKoR,MAAMe,IAGZD,aAAcL,IAClBK,EAAKP,EAASX,EAAgBkB,KAG1BC,aAAcN,IAClBM,EAAKR,EAASX,EAAgBmB,KAG3BD,GAAOC,EAAZ,CAIA,IAAIpP,EAAMmP,EAAGjB,GAAK,IAAMkB,EAAGlB,GACvBqB,EAAO,IAAIC,EAAUL,EAAIC,EAAI1G,GAgBjC,OAfA6G,EAAKR,UAAY9R,KAEbA,KAAKwR,YACPU,EAAGM,SAASvP,KAAKqP,GACjBH,EAAGM,QAAQxP,KAAKqP,IAGlBJ,EAAGb,MAAMpO,KAAKqP,GAEVJ,IAAOC,GACTA,EAAGd,MAAMpO,KAAKqP,GAGhBtS,KAAKqR,MAAMpO,KAAKqP,GAChBF,EAASrP,GAAOuP,EACTA,CAnBP,CAoBF,EAOApB,EAAM5Q,UAAUoS,eAAiB,SAAUjH,GACzC,IAAIzB,EAAShK,KAAK2S,SAAS7M,YAAY2F,GACvC,OAAOzL,KAAKqR,MAAMrH,EACpB,EAOAkH,EAAM5Q,UAAUsS,QAAU,SAAUV,EAAIC,GAClCD,aAAcL,IAChBK,EAAKA,EAAGjB,IAGNkB,aAAcN,IAChBM,EAAKA,EAAGlB,IAGV,IAAImB,EAAWpS,KAAKuR,UAEpB,OAAIvR,KAAKwR,UACAY,EAASF,EAAK,IAAMC,GAEpBC,EAASF,EAAK,IAAMC,IAAOC,EAASD,EAAK,IAAMD,EAE1D,EAOAhB,EAAM5Q,UAAUuS,SAAW,SAAU1G,EAAIrM,GAIvC,IAHA,IAAIsR,EAAQpR,KAAKoR,MACb1J,EAAM0J,EAAM9R,OAEPqC,EAAI,EAAGA,EAAI+F,EAAK/F,IACnByP,EAAMzP,GAAG8J,WAAa,GACxBU,EAAG/C,KAAKtJ,EAASsR,EAAMzP,GAAIA,EAGjC,EAOAuP,EAAM5Q,UAAUwS,SAAW,SAAU3G,EAAIrM,GAIvC,IAHA,IAAIuR,EAAQrR,KAAKqR,MACb3J,EAAM2J,EAAM/R,OAEPqC,EAAI,EAAGA,EAAI+F,EAAK/F,IACnB0P,EAAM1P,GAAG8J,WAAa,GAAK4F,EAAM1P,GAAGoR,MAAMtH,WAAa,GAAK4F,EAAM1P,GAAGqR,MAAMvH,WAAa,GAC1FU,EAAG/C,KAAKtJ,EAASuR,EAAM1P,GAAIA,EAGjC,EAQAuP,EAAM5Q,UAAU2S,qBAAuB,SAAU9G,EAAI+G,EAAWC,EAAWrT,GAKzE,GAJMoT,aAAqBrB,IACzBqB,EAAYlT,KAAKsR,UAAUN,EAAgBkC,KAGxCA,EAAL,CAMA,IAFA,IAAIE,EAAyB,QAAdD,EAAsB,WAA2B,OAAdA,EAAqB,UAAY,QAE1ExR,EAAI,EAAGA,EAAI3B,KAAKoR,MAAM9R,OAAQqC,IACrC3B,KAAKoR,MAAMzP,GAAG0R,WAAY,EAG5B,IAAIlH,EAAG/C,KAAKtJ,EAASoT,EAAW,MAAhC,CAIA,IAAII,EAAQ,CAACJ,GAEb,MAAOI,EAAMhU,OACX,KAAIiU,EAAcD,EAAMtR,QACpBqP,EAAQkC,EAAYH,GAExB,IAASzR,EAAI,EAAGA,EAAI0P,EAAM/R,OAAQqC,IAAK,CACrC,IAAI6R,EAAInC,EAAM1P,GACV8R,EAAYD,EAAET,QAAUQ,EAAcC,EAAER,MAAQQ,EAAET,MAEtD,IAAKU,EAAUJ,UAAW,CACxB,GAAIlH,EAAG/C,KAAKtJ,EAAS2T,EAAWF,GAE9B,OAGFD,EAAMrQ,KAAKwQ,GACXA,EAAUJ,WAAY,CACxB,CACF,CAhB+B,CALjC,CAVA,CAiCF,EASAnC,EAAM5Q,UAAUI,OAAS,WAMvB,IALA,IAAI6H,EAAOvI,KAAKuI,KACZoK,EAAW3S,KAAK2S,SAChBvB,EAAQpR,KAAKoR,MACbC,EAAQrR,KAAKqR,MAER1P,EAAI,EAAG+F,EAAM0J,EAAM9R,OAAQqC,EAAI+F,EAAK/F,IAC3CyP,EAAMzP,GAAG8J,WAAa,EAGxB,IAAS9J,EAAI,EAAG+F,EAAMa,EAAK5B,QAAShF,EAAI+F,EAAK/F,IAC3CyP,EAAM7I,EAAKzC,YAAYnE,IAAI8J,UAAY9J,EAGzCgR,EAASe,YAAW,SAAUzK,GAC5B,IAAIqJ,EAAOjB,EAAMsB,EAAS7M,YAAYmD,IACtC,OAAOqJ,EAAKS,MAAMtH,WAAa,GAAK6G,EAAKU,MAAMvH,WAAa,CAC9D,IAEA,IAAS9J,EAAI,EAAG+F,EAAM2J,EAAM/R,OAAQqC,EAAI+F,EAAK/F,IAC3C0P,EAAM1P,GAAG8J,WAAa,EAGxB,IAAS9J,EAAI,EAAG+F,EAAMiL,EAAShM,QAAShF,EAAI+F,EAAK/F,IAC/C0P,EAAMsB,EAAS7M,YAAYnE,IAAI8J,UAAY9J,CAE/C,EAOAuP,EAAM5Q,UAAU8L,MAAQ,WAKtB,IAJA,IAAIuH,EAAQ,IAAIzC,EAAMlR,KAAKwR,WACvBJ,EAAQpR,KAAKoR,MACbC,EAAQrR,KAAKqR,MAER1P,EAAI,EAAGA,EAAIyP,EAAM9R,OAAQqC,IAChCgS,EAAMjC,QAAQN,EAAMzP,GAAGsP,GAAIG,EAAMzP,GAAG8J,WAGtC,IAAS9J,EAAI,EAAGA,EAAI0P,EAAM/R,OAAQqC,IAAK,CACrC,IAAI6R,EAAInC,EAAM1P,GACdgS,EAAM1B,QAAQuB,EAAET,MAAM9B,GAAIuC,EAAER,MAAM/B,GAAIuC,EAAE/H,UAC1C,CAEA,OAAOkI,CACT,EAGOzC,CACT,CA/RA,GAiSIW,EAEJ,WACE,SAASA,EAAUZ,EAAIxF,GACrBzL,KAAKyS,QAAU,GACfzS,KAAKwS,SAAW,GAChBxS,KAAKqR,MAAQ,GACbrR,KAAKyL,WAAa,EAClBzL,KAAKiR,GAAW,MAANA,EAAa,GAAKA,EAC5BjR,KAAKyL,UAAyB,MAAbA,GAAqB,EAAIA,CAC5C,CAwDA,OAlDAoG,EAAUvR,UAAUsT,OAAS,WAC3B,OAAO5T,KAAKqR,MAAM/R,MACpB,EAMAuS,EAAUvR,UAAUuT,SAAW,WAC7B,OAAO7T,KAAKyS,QAAQnT,MACtB,EAMAuS,EAAUvR,UAAUwT,UAAY,WAC9B,OAAO9T,KAAKwS,SAASlT,MACvB,EAEAuS,EAAUvR,UAAUyT,SAAW,SAAUC,GACvC,KAAIhU,KAAKyL,UAAY,GAArB,CAIA,IAAIkI,EAAQ3T,KAAK8R,UACbmC,EAAYN,EAAMpL,KAAK2L,aAAalU,KAAKyL,WAC7C,OAAOwI,EAAUF,SAASC,EAJ1B,CAKF,EAEAnC,EAAUvR,UAAU6T,uBAAyB,WAM3C,IALA,IAAIC,EAAc,CAChB9B,KAAM,GACNV,KAAM,IAGCjQ,EAAI,EAAGA,EAAI3B,KAAKqR,MAAM/R,OAAQqC,IAAK,CAC1C,IAAI0S,EAAerU,KAAKqR,MAAM1P,GAE1B0S,EAAa5I,UAAY,IAI7B2I,EAAY9B,KAAKrP,KAAKoR,EAAa5I,WACnC2I,EAAYxC,KAAK3O,KAAKoR,EAAatB,MAAMtH,UAAW4I,EAAarB,MAAMvH,WACzE,CAEA,OAAO2I,CACT,EAEOvC,CACT,CAjEA,GAmEIU,EAEJ,WACE,SAASA,EAAUL,EAAIC,EAAI1G,GACzBzL,KAAKyL,WAAa,EAClBzL,KAAK+S,MAAQb,EACblS,KAAKgT,MAAQb,EACbnS,KAAKyL,UAAyB,MAAbA,GAAqB,EAAIA,CAC5C,CAoBA,OAjBA8G,EAAUjS,UAAUyT,SAAW,SAAUC,GACvC,KAAIhU,KAAKyL,UAAY,GAArB,CAIA,IAAIkI,EAAQ3T,KAAK8R,UACbmC,EAAYN,EAAMhB,SAASuB,aAAalU,KAAKyL,WACjD,OAAOwI,EAAUF,SAASC,EAJ1B,CAKF,EAEAzB,EAAUjS,UAAU6T,uBAAyB,WAC3C,MAAO,CACL7B,KAAM,CAACtS,KAAKyL,WACZmG,KAAM,CAAC5R,KAAK+S,MAAMtH,UAAWzL,KAAKgT,MAAMvH,WAE5C,EAEO8G,CACT,CA3BA,GA6BA,SAAS+B,EAA0BC,EAAUC,GAC3C,MAAO,CAILC,SAAU,SAAUlF,GAClB,IAAIhH,EAAOvI,KAAKuU,GAAUC,GAC1B,OAAOjM,EAAKmM,WAAWxN,IAAIqB,EAAKoM,kBAAkBpF,GAAa,SAAUvP,KAAKyL,UAChF,EAEAmJ,UAAW,SAAU7R,EAAKqH,GACxBpK,KAAKyL,WAAa,GAAKzL,KAAKuU,GAAUC,GAAUK,cAAc7U,KAAKyL,UAAW1I,EAAKqH,EACrF,EACA0K,UAAW,SAAU/R,GACnB,OAAO/C,KAAKuU,GAAUC,GAAUO,cAAc/U,KAAKyL,UAAW1I,EAChE,EACAiS,UAAW,SAAUC,EAAQC,GAC3BlV,KAAKyL,WAAa,GAAKzL,KAAKuU,GAAUC,GAAUW,cAAcnV,KAAKyL,UAAWwJ,EAAQC,EACxF,EACAE,UAAW,WACT,OAAOpV,KAAKuU,GAAUC,GAAUa,cAAcrV,KAAKyL,UACrD,EACA6J,aAAc,WACZ,OAAOtV,KAAKuU,GAAUC,GAAUe,iBAAiBvV,KAAKyL,UACxD,EACA3F,YAAa,WACX,OAAO9F,KAAKuU,GAAUC,GAAU1O,YAAY9F,KAAKyL,UACnD,EAEJ,CAKA4G,EAAAA,MAAaR,EAAWyC,EAA0B,YAAa,SAC/DjC,EAAAA,MAAaE,EAAW+B,EAA0B,YAAa,aAC/D,S,uCChbIkB,EAAU,EAEVC,EAEJ,WACE,SAASA,EAAYC,GACnB1V,KAAK2V,WAAaD,EAAIC,YAAc,GACpC3V,KAAK4V,aAAeF,EAAIG,YACxB7V,KAAK8V,eAAiBJ,EAAIK,cAC1B/V,KAAKgW,MAAQR,CACf,CA2EA,OAzEAC,EAAYQ,kBAAoB,SAAUC,GACxC,IAAIC,EAASD,EAAUC,OACnB5N,EAAO4N,EAAO5N,KACdoN,EAAapN,IAAQ5F,EAAAA,EAAAA,KAAI4F,EAAM6N,GACnC,OAAO,IAAIX,EAAY,CACrBE,WAAYA,EACZE,aAAcF,EAEdI,eAAuC,IAAxBI,EAAOE,cAE1B,EAIAZ,EAAYnV,UAAUgW,WAAa,SAAUC,GAE3C,OAAOvW,KAAKwW,kBAAkBtP,IAAIqP,EACpC,EAMAd,EAAYnV,UAAUuH,gBAAkB,SAAU0O,GAChD,IAAIE,EACAZ,EAAc7V,KAAK4V,aAMvB,KAAKc,EAAAA,EAAAA,UAASH,KAAcV,EAC1B,OAAOU,EAWT,GAAIV,IAAgB7V,KAAK8V,eAGvB,OAFAW,EAAQzW,KAAK2V,WAAWrW,OACxBU,KAAK2V,WAAWc,GAASF,EAClBE,EAGT,IAAI9T,EAAM3C,KAAKwW,kBAgBf,OAbAC,EAAQ9T,EAAIuE,IAAIqP,GAEH,MAATE,IACEZ,GACFY,EAAQzW,KAAK2V,WAAWrW,OACxBU,KAAK2V,WAAWc,GAASF,EAEzB5T,EAAIwE,IAAIoP,EAAUE,IAElBA,EAAQ9M,KAIL8M,CACT,EAGAhB,EAAYnV,UAAUkW,gBAAkB,WACtC,OAAOxW,KAAK2W,OAAS3W,KAAK2W,MAAOpR,EAAAA,EAAAA,eAAcvF,KAAK2V,YACtD,EAEOF,CACT,CAlFA,GAoFA,SAASW,EAAQ7F,GACf,OAAIqG,EAAAA,EAAAA,UAASrG,IAAqB,MAAbA,EAAInG,MAChBmG,EAAInG,MAEJmG,EAAM,EAEjB,CAEA,Q,wXCjCIsG,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,E,oIAnBAP,EAAW,WACXjU,EAAM,MACNa,EAAuC,qBAAfC,WAA6BjC,MAAQiC,WAG7D2T,EAAY,QACZC,GAAmB,EAEnBC,EAA0B,CAAC,gBAAiB,YAAa,UAAW,sBAAuB,cAAe,aAAc,WAAY,kBAAmB,cAAe,YAAa,oBACnLC,EAAmB,CAAC,sBAWpBC,EACJ,WAME,SAASA,EAAWC,EAAiBC,GAgCnC,IAAI1Q,EA/BJhH,KAAKwG,KAAO,OACZxG,KAAK2X,aAAc,EACnB3X,KAAK4X,UAAY,GACjB5X,KAAK6X,QAAU,GAKf7X,KAAK8X,QAAU,CAAC,EAEhB9X,KAAK+X,QAAU,CAAC,EAEhB/X,KAAKgY,aAAe,GAEpBhY,KAAKiY,aAAe,GAEpBjY,KAAKkY,YAAc,GAEnBlY,KAAKmY,mBAAqB,CAAC,EAC3BnY,KAAKoY,iBAAmB,CAAC,EAKzBpY,KAAKqY,eAAgB,EAGrBrY,KAAKsY,qBAAuB,CAAC,eAAgB,aAAc,iBAAkB,OAE7EtY,KAAKuY,kBAAoB,CAAC,aAAc,eACxCvY,KAAKwY,mBAAqB,CAAC,aAAc,kBAEzC,IAAIC,GAAoB,GACpB,QAAmBhB,IACrBzQ,EAAayQ,EAAgBzQ,WAC7BhH,KAAK2X,YAAcF,EAAgBiB,qBACnC1Y,KAAK2Y,QAAUlB,IAEfgB,GAAoB,EACpBzR,EAAayQ,GAEfzQ,EAAaA,GAAc,CAAC,IAAK,KAMjC,IALA,IAAI4R,EAAiB,CAAC,EAClBC,EAAiB,GACjBC,EAAqB,CAAC,EACtBC,GAAc,EACdC,EAAW,CAAC,EACPrX,EAAI,EAAGA,EAAIqF,EAAW1H,OAAQqC,IAAK,CAE1C,IAAIsX,EAAejS,EAAWrF,GAC1BuX,EAAgB,WAAgBD,GAAgB,IAAI,IAAsB,CAC5EE,KAAMF,IACDA,aAAwB,IAAmEA,EAA1C,IAAI,IAAsBA,GAC9EG,EAAgBF,EAAcC,KAClCD,EAAc1S,KAAO0S,EAAc1S,MAAQ,QACtC0S,EAAcG,WACjBH,EAAcG,SAAWD,EACzBF,EAAcI,cAAgB,GAEhC,IAAIC,EAAYL,EAAcK,UAAYL,EAAcK,WAAa,CAAC,EACtEV,EAAe5V,KAAKmW,GACpBR,EAAeQ,GAAiBF,EACD,MAA3BF,EAASI,KACXL,GAAc,GAEZG,EAAcM,wBAChBV,EAAmBM,GAAiB,IAEX,IAAvBG,EAAUE,WACZzZ,KAAK0Z,YAAc/X,GAEI,IAArB4X,EAAUI,SACZ3Z,KAAK4Z,UAAYjY,GAKf8W,IACFS,EAAcW,cAAgBlY,EAElC,CAMA,GALA3B,KAAKgH,WAAa6R,EAClB7Y,KAAK8Z,UAAYlB,EACjB5Y,KAAK+Z,sBAAsBhB,GAC3B/Y,KAAK0X,UAAYA,EACjB1X,KAAKga,oBAAsBlB,EACvB9Y,KAAK2X,YAAa,CACpB,IAAIsC,EAAiBja,KAAKka,cAAgB,kBAC1C,OAAYrB,GAAgB,SAAU/R,GACpCmT,EAAe9S,IAAIyR,EAAe9R,GAAS+S,cAAe/S,EAC5D,GACF,CACF,CA80BA,OA3zBA0Q,EAAWlX,UAAU6Z,aAAe,SAAU5T,GAC5C,IAAI/B,EAASxE,KAAKoa,mBAAmB7T,GACrC,GAAc,MAAV/B,EACF,OAAO+B,EAGT,GADA/B,EAAS+B,GACJvG,KAAK2X,YACR,OAAO3X,KAAKgH,WAAWxC,GAIzB,IAAIsC,EAAU9G,KAAKka,cAAchT,IAAI1C,GACrC,GAAe,MAAXsC,EACF,OAAOA,EAET,IAAIuT,EAAera,KAAK2Y,QAAQ2B,mBAAmB9V,GACnD,OAAI6V,EACKA,EAAalB,UADtB,CAGF,EAMA3B,EAAWlX,UAAUqU,kBAAoB,SAAUpO,GACjD,IAAI/B,EAASxE,KAAKoa,mBAAmB7T,GACrC,GAAc,MAAV/B,EACF,OAAOA,EAET,GAAW,MAAP+B,EACF,OAAQ,EAEV,IAAI4B,EAAUnI,KAAKua,YAAYhU,GAC/B,OAAO4B,EAAUA,EAAQ0R,cAAgB7Z,KAAK2X,YAAc3X,KAAK2Y,QAAQ6B,wBAAwBjU,IAAQ,CAC3G,EAqBAiR,EAAWlX,UAAU8Z,mBAAqB,SAAU7T,GAClD,GAAI,WAAgBA,IACV,MAAPA,IAAgBuB,MAAMvB,KAASvG,KAAKua,YAAYhU,MAAUvG,KAAK2X,aAAe3X,KAAK2Y,QAAQ6B,wBAAwBjU,GAAO,GAC3H,OAAQA,CAEZ,EACAiR,EAAWlX,UAAUma,kBAAoB,SAAUlU,GACjD,IAAI/B,EAASxE,KAAK2U,kBAAkBpO,GAMpC,OAAO/B,CACT,EAQAgT,EAAWlX,UAAUoa,iBAAmB,SAAUnU,GAEhD,OAAOvG,KAAKua,YAAYva,KAAKma,aAAa5T,GAC5C,EACAiR,EAAWlX,UAAUyZ,sBAAwB,SAAUhB,GACrD,IAAIH,EAAiB5Y,KAAK8Z,UAC1B9Z,KAAKua,YAAcxB,EAAc,SAAUjS,GACzC,OAAO8R,EAAe+B,eAAe7T,GAAW8R,EAAe9R,QAAW8T,CAC5E,EAAI,SAAU9T,GACZ,OAAO8R,EAAe9R,EACxB,CACF,EAKA0Q,EAAWlX,UAAUua,qBAAuB,WAC1C,OAAO7a,KAAK8a,YAAYC,gBAAgB1W,OAC1C,EACAmT,EAAWlX,UAAU0a,aAAe,SAAU3B,EAAUpQ,GACtD,IAAIgS,EAAoBjb,KAAK8a,YAC7B,GAAW,MAAP7R,EACF,OAAOgS,EAAkBC,uBAAuB7B,GAElD,IAAInN,EAAO+O,EAAkBE,OAAO9B,GACpC,OAAOnN,EAAOA,EAAKjD,GAAO,IAC5B,EACAuO,EAAWlX,UAAU8a,iBAAmB,SAAU/B,GAChD,IAAI4B,EAAoBjb,KAAK8a,YACzB5O,EAAO+O,EAAkBE,OAAO9B,GACpC,OAAQnN,GAAQ,IAAI7H,OACtB,EACAmT,EAAWlX,UAAUoU,SAAW,WAC9B,OAAO1U,KAAKqb,MACd,EAWA7D,EAAWlX,UAAUkF,SAAW,SAAU+C,EAAM+S,EAAU3V,GACxD,IACIpB,EADAgX,EAAQvb,KAKZ,GAHIuI,aAAgB,OAClBhE,EAAQgE,IAELhE,EAAO,CACV,IAAIyC,EAAahH,KAAKgH,WAClBvB,GAAW,QAAiB8C,IAAS,cAAmBA,GAAQ,IAAI,KAAoBA,EAAMvB,EAAW1H,QAAUiJ,EACvHhE,EAAQ,IAAI,KACZ,IAAIqU,EAAiBjW,EAAIqE,GAAY,SAAUF,GAC7C,MAAO,CACLN,KAAM+U,EAAMzB,UAAUhT,GAASN,KAC/BC,SAAUK,EAEd,IACAvC,EAAMiB,SAASC,EAAUmT,EAAgBjT,EAC3C,CACA3F,KAAKqb,OAAS9W,EAEdvE,KAAK4X,WAAa0D,GAAY,IAAIjX,QAClCrE,KAAK6X,QAAU,GACf7X,KAAKwb,iBAAmB,CAAC,EACzBxb,KAAKyb,QAAQ,EAAGlX,EAAMoC,SAGtB3G,KAAK8a,aAAc,OAAoB9a,KAAMA,KAAK2Y,SAClD3Y,KAAK0b,WAAa1b,KAAK8a,YAAYY,UACrC,EAKAlE,EAAWlX,UAAUgI,WAAa,SAAUC,GAC1C,IAAIqE,EAAQ5M,KAAKqb,OAAO/S,WAAWC,GACnCvI,KAAKyb,QAAQ7O,EAAM,GAAIA,EAAM,GAC/B,EAiBA4K,EAAWlX,UAAUoI,aAAe,SAAUC,EAAQgT,GACpD,IAAIC,EAAK5b,KAAKqb,OAAO3S,aAAaC,EAAQgT,EAAMrc,QAC9CkJ,EAAQoT,EAAGpT,MACX9D,EAAMkX,EAAGlX,IACPmX,EAAuB7b,KAAK8b,wBAEhC,GADA9b,KAAK+b,qBACDJ,EACF,IAAK,IAAI1S,EAAMT,EAAOS,EAAMvE,EAAKuE,IAAO,CACtC,IAAIC,EAAYD,EAAMT,EACtBxI,KAAK4X,UAAU3O,GAAO0S,EAAMzS,GACxB2S,GACF1E,EAAenX,KAAMiJ,EAEzB,CAEJ,EACAuO,EAAWlX,UAAUyb,mBAAqB,WAGxC,IAFA,IAAIxX,EAAQvE,KAAKqb,OACbrU,EAAahH,KAAKgH,WACbrF,EAAI,EAAGA,EAAIqF,EAAW1H,OAAQqC,IAAK,CAC1C,IAAIwG,EAAUnI,KAAK8Z,UAAU9S,EAAWrF,IACpCwG,EAAQd,aACV9C,EAAM6C,mBAAmBe,EAAQ0R,cAAe1R,EAAQd,YAE5D,CACF,EACAmQ,EAAWlX,UAAUwb,sBAAwB,WAC3C,IAAIrW,EAAWzF,KAAKqb,OAAOzU,cAC3B,OAAyB,MAAlB5G,KAAK4Z,WAAqBnU,EAASQ,YAAYG,eAAiB,OAA8BX,EAAS6D,WAChH,EACAkO,EAAWlX,UAAUmb,QAAU,SAAUjT,EAAO9D,GAC9C,KAAI8D,GAAS9D,GAAb,CAGA,IAAIH,EAAQvE,KAAKqb,OACb5V,EAAWlB,EAAMqC,cACrB5G,KAAK+b,qBACL,IAAIT,EAAWtb,KAAK4X,UAChBoE,EAAShc,KAAK6X,QACdzR,EAAeX,EAASQ,YAAYG,aACpC6V,EAAmB7V,IAAiB,KASxC,GAAI6V,IAAqBxW,EAASyW,KAEhC,IADA,IAAIC,EAAiB,GACZlT,EAAMT,EAAOS,EAAMvE,EAAKuE,IAAO,CAEtC,IAAIM,EAAW9D,EAAS+D,QAAQP,EAAKkT,GAIrC,IAHKnc,KAAKqY,gBAAiB,QAAiB9O,KAC1CvJ,KAAKqY,eAAgB,GAEnB9O,EAAU,CACZ,IAAIkQ,EAAWlQ,EAAS4P,KACH,MAAjBmC,EAASrS,IAA4B,MAAZwQ,IAC3B6B,EAASrS,IAAO,QAAoBwQ,EAAU,OAEhD,IAAIE,EAASpQ,EAAS0H,GACH,MAAf+K,EAAO/S,IAA0B,MAAV0Q,IACzBqC,EAAO/S,IAAO,QAAoB0Q,EAAQ,MAE9C,CACF,CAEF,GAAI3Z,KAAK8b,wBACP,IAAS7S,EAAMT,EAAOS,EAAMvE,EAAKuE,IAC/BkO,EAAenX,KAAMiJ,GAGzB4N,EAAqB7W,KAzCrB,CA0CF,EAgBAwX,EAAWlX,UAAU8b,qBAAuB,SAAU7V,GACpD,OAAOvG,KAAKmY,mBAAmB5R,IAAQvG,KAAKqb,OAAOxL,cAAc7P,KAAKya,kBAAkBlU,GAC1F,EAMAiR,EAAWlX,UAAU+b,qBAAuB,SAAUC,EAAQ/V,GAC5DA,EAAMvG,KAAKma,aAAa5T,GACxBvG,KAAKmY,mBAAmB5R,GAAO+V,EAAOjY,OACxC,EACAmT,EAAWlX,UAAUic,mBAAqB,SAAUxZ,GAClD,OAAO/C,KAAKoY,iBAAiBrV,EAC/B,EACAyU,EAAWlX,UAAUkc,mBAAqB,SAAUzZ,EAAKqH,GACvDwM,EAAS7T,GAAO,SAAc/C,KAAKoY,iBAAkBrV,GAAO/C,KAAKoY,iBAAiBrV,GAAOqH,CAC3F,EAQAoN,EAAWlX,UAAU8V,QAAU,SAAUnN,GACvC,IAAI4B,EAAW7K,KAAK8F,YAAYmD,GAC5BkQ,EAAOnZ,KAAK4X,UAAU/M,GAO1B,OANY,MAARsO,GAAoC,MAApBnZ,KAAK0Z,cACvBP,EAAOpC,EAAmB/W,KAAMA,KAAK0Z,YAAa7O,IAExC,MAARsO,IACFA,EAAO,IAEFA,CACT,EACA3B,EAAWlX,UAAUmc,aAAe,SAAUjY,EAAQyE,GACpD,IAAIyT,EAAU1c,KAAKqb,OAAOnU,IAAI1C,EAAQyE,GAClC5B,EAAcrH,KAAKqb,OAAOnT,eAAe1D,GAC7C,OAAI6C,EACKA,EAAYsO,WAAW+G,GAEzBA,CACT,EAQAlF,EAAWlX,UAAUwW,MAAQ,SAAU7N,GACrC,OAAO6N,EAAM9W,KAAMA,KAAK8F,YAAYmD,GACtC,EACAuO,EAAWlX,UAAUqG,MAAQ,WAC3B,OAAO3G,KAAKqb,OAAO1U,OACrB,EAOA6Q,EAAWlX,UAAU4G,IAAM,SAAUX,EAAK0C,GACxC,IAAI1E,EAAQvE,KAAKqb,OACblT,EAAUnI,KAAK8Z,UAAUvT,GAC7B,GAAI4B,EACF,OAAO5D,EAAM2C,IAAIiB,EAAQ0R,cAAe5Q,EAE5C,EAKAuO,EAAWlX,UAAUyJ,cAAgB,SAAUxD,EAAKyD,GAClD,IAAIzF,EAAQvE,KAAKqb,OACblT,EAAUnI,KAAK8Z,UAAUvT,GAC7B,GAAI4B,EACF,OAAO5D,EAAMwF,cAAc5B,EAAQ0R,cAAe7P,EAEtD,EACAwN,EAAWlX,UAAUuL,WAAa,WAChC,OAAO7L,KAAKqb,OAAOxP,YACrB,EACA2L,EAAWlX,UAAUuP,cAAgB,SAAUtJ,GAC7C,OAAOvG,KAAKqb,OAAOxL,cAAc7P,KAAKya,kBAAkBlU,GAC1D,EACAiR,EAAWlX,UAAU2J,OAAS,SAAU1D,GACtC,OAAOvG,KAAKqb,OAAOpR,OAAOjK,KAAKya,kBAAkBlU,GACnD,EACAiR,EAAWlX,UAAU+J,UAAY,SAAU9D,GACzC,OAAOvG,KAAKqb,OAAOhR,UAAUrK,KAAKya,kBAAkBlU,GACtD,EACAiR,EAAWlX,UAAUuJ,UAAY,SAAU7C,EAAYiC,GACrD,IAAIsS,EAAQvb,KACRuE,EAAQvE,KAAKqb,OACjB,OAAO,UAAerU,GAAczC,EAAMsF,UAAUlH,EAAIqE,GAAY,SAAUT,GAC5E,OAAOgV,EAAMd,kBAAkBlU,EACjC,IAAI0C,GAAO1E,EAAMsF,UAAU7C,EAC7B,EAMAwQ,EAAWlX,UAAUqc,SAAW,SAAU1T,GAExC,IADA,IAAI2T,EAAwB5c,KAAK8a,YAAY8B,sBACpCjb,EAAI,EAAG+F,EAAMkV,EAAsBtd,OAAQqC,EAAI+F,EAAK/F,IAI3D,GAAImG,MAAM9H,KAAKqb,OAAOnU,IAAI0V,EAAsBjb,GAAIsH,IAClD,OAAO,EAGX,OAAO,CACT,EAKAuO,EAAWlX,UAAUuc,YAAc,SAAU1D,GAC3C,IAAK,IAAIxX,EAAI,EAAG+F,EAAM1H,KAAKqb,OAAO1U,QAAShF,EAAI+F,EAAK/F,IAClD,GAAI3B,KAAKoW,QAAQzU,KAAOwX,EACtB,OAAOxX,EAGX,OAAQ,CACV,EACA6V,EAAWlX,UAAUwF,YAAc,SAAUmD,GAC3C,OAAOjJ,KAAKqb,OAAOvV,YAAYmD,EACjC,EACAuO,EAAWlX,UAAUsK,gBAAkB,SAAUC,GAC/C,OAAO7K,KAAKqb,OAAOzQ,gBAAgBC,EACrC,EASA2M,EAAWlX,UAAUwc,WAAa,SAAUvW,EAAK6D,GAC/C,IAAI2S,EAAkBxW,GAAOvG,KAAKga,oBAAoBzT,GAMtD,IAAIsE,EAAWkS,EAAgB3S,GAC/B,OAAgB,MAAZS,GAAoB/C,MAAM+C,GACrBwM,EAEFxM,CACT,EAUA2M,EAAWlX,UAAU6K,iBAAmB,SAAU5E,EAAK6D,EAAOgB,GAC5D,OAAOpL,KAAKqb,OAAOlQ,iBAAiBnL,KAAKya,kBAAkBlU,GAAM6D,EAAOgB,EAC1E,EACAoM,EAAWlX,UAAUiK,KAAO,SAAU2B,EAAMC,EAAI6Q,GAG1C,aAAkB9Q,KACpB8Q,EAAM7Q,EACNA,EAAKD,EACLA,EAAO,IAGT,IAAI+Q,EAAOD,GAAOhd,KACdkd,EAAava,EAAIqU,EAAoB9K,GAAOlM,KAAKya,kBAAmBza,MACxEA,KAAKqb,OAAO9Q,KAAK2S,EAAYD,EAAO,OAAY9Q,EAAI8Q,GAAQ9Q,EAC9D,EACAqL,EAAWlX,UAAUoT,WAAa,SAAUxH,EAAMC,EAAI6Q,GAGhD,aAAkB9Q,KACpB8Q,EAAM7Q,EACNA,EAAKD,EACLA,EAAO,IAGT,IAAI+Q,EAAOD,GAAOhd,KACdkd,EAAava,EAAIqU,EAAoB9K,GAAOlM,KAAKya,kBAAmBza,MAExE,OADAA,KAAKqb,OAASrb,KAAKqb,OAAOpP,OAAOiR,EAAYD,EAAO,OAAY9Q,EAAI8Q,GAAQ9Q,GACrEnM,IACT,EAMAwX,EAAWlX,UAAUqM,YAAc,SAAUC,GAG3C,IAAI2O,EAAQvb,KACRmd,EAAa,CAAC,EACdjR,EAAO,OAAYU,GACnBsQ,EAAa,GAOjB,OANA,OAAYhR,GAAM,SAAU3F,GAC1B,IAAI/B,EAAS+W,EAAMd,kBAAkBlU,GACrC4W,EAAW3Y,GAAUoI,EAAMrG,GAC3B2W,EAAWja,KAAKuB,EAClB,IACAxE,KAAKqb,OAASrb,KAAKqb,OAAO1O,YAAYwQ,GAC/Bnd,IACT,EAGAwX,EAAWlX,UAAU8c,SAAW,SAAUlR,EAAMC,EAAI6Q,GAG9C,aAAkB9Q,KACpB8Q,EAAM7Q,EACNA,EAAKD,EACLA,EAAO,IAGT8Q,EAAMA,GAAOhd,KACb,IAAIqd,EAAS,GAIb,OAHArd,KAAKuK,KAAK2B,GAAM,WACdmR,EAAOpa,KAAKkJ,GAAMA,EAAGM,MAAMzM,KAAMsd,WACnC,GAAGN,GACIK,CACT,EACA7F,EAAWlX,UAAUqC,IAAM,SAAUuJ,EAAMC,EAAI6Q,EAAKO,GAIlD,IAAIN,EAAOD,GAAOO,GAAavd,KAC3Bkd,EAAava,EAAIqU,EAAoB9K,GAAOlM,KAAKya,kBAAmBza,MACpEwd,EAAOtG,EAAyBlX,MAEpC,OADAwd,EAAKnC,OAASrb,KAAKqb,OAAO1Y,IAAIua,EAAYD,EAAO,OAAY9Q,EAAI8Q,GAAQ9Q,GAClEqR,CACT,EACAhG,EAAWlX,UAAUkN,OAAS,SAAUtB,EAAMC,EAAI6Q,EAAKO,GACrD,IAEIN,EAAOD,GAAOO,GAAavd,KAS/B,IAAIkd,EAAava,EAAIqU,EAAoB9K,GAAOlM,KAAKya,kBAAmBza,MAKxEA,KAAKqb,OAAO7N,OAAO0P,EAAYD,EAAO,OAAY9Q,EAAI8Q,GAAQ9Q,EAChE,EAMAqL,EAAWlX,UAAUgP,WAAa,SAAUC,EAAWvB,EAAMwB,EAAaC,GACxE,IAAI+N,EAAOtG,EAAyBlX,MAEpC,OADAwd,EAAKnC,OAASrb,KAAKqb,OAAO/L,WAAWtP,KAAKya,kBAAkBlL,GAAYvB,EAAMwB,EAAaC,GACpF+N,CACT,EAOAhG,EAAWlX,UAAUwN,eAAiB,SAAUC,EAAgBC,GAC9D,IAAIwP,EAAOtG,EAAyBlX,MAEpC,OADAwd,EAAKnC,OAASrb,KAAKqb,OAAOvN,eAAe9N,KAAKya,kBAAkB1M,GAAiBC,GAC1EwP,CACT,EACAhG,EAAWlX,UAAU4P,eAAiB,SAAUjH,GAC9C,OAAOjJ,KAAKqb,OAAOnL,eAAejH,EACpC,EAMAuO,EAAWlX,UAAU4T,aAAe,SAAUjL,GAC5C,IAAIyO,EAAY1X,KAAK0X,UACjBnO,EAAWvJ,KAAKkQ,eAAejH,GACnC,OAAO,IAAI,IAAMM,EAAUmO,EAAWA,GAAaA,EAAU+F,QAC/D,EAKAjG,EAAWlX,UAAUoL,KAAO,SAAUgS,GACpC,IAAIC,EAAW3d,KACf,OAAO,IAAI,IAAW0d,EAAYA,EAAUhJ,WAAW7I,aAAe,GAAI7L,KAAK0U,WAAW7I,cAAc,SAAU5C,GAChH,OAAO6N,EAAM4G,EAAWzU,EAC1B,IAAG,SAAUA,GACX,OAAO6N,EAAM6G,EAAU1U,EACzB,GACF,EAKAuO,EAAWlX,UAAUwU,UAAY,SAAU/R,GACzC,IAAI6a,EAAS5d,KAAK8X,QAClB,OAAO8F,GAAUA,EAAO7a,EAC1B,EACAyU,EAAWlX,UAAUsU,UAAY,SAAUiJ,EAAOjW,GAChD5H,KAAK8X,QAAU9X,KAAK8X,SAAW,CAAC,EAC5BlB,EAASiH,GACX,SAAc7d,KAAK8X,QAAS+F,GAE5B7d,KAAK8X,QAAQ+F,GAASjW,CAE1B,EAMA4P,EAAWlX,UAAUyU,cAAgB,SAAU9L,EAAKlG,GAClD,IAAI+a,EAAa9d,KAAKgY,aAAa/O,GAC/BrB,EAAMkW,GAAcA,EAAW/a,GACnC,OAAW,MAAP6E,EAEK5H,KAAK8U,UAAU/R,GAEjB6E,CACT,EAKA4P,EAAWlX,UAAUyd,cAAgB,WACnC,OAAO/d,KAAKgY,aAAa1Y,OAAS,CACpC,EAMAkY,EAAWlX,UAAU0d,uBAAyB,SAAU/U,EAAKlG,GAC3D,IAAIkb,EAAcje,KAAKgY,aACnB8F,EAAaG,EAAYhV,GACxB6U,IACHA,EAAaG,EAAYhV,GAAO,CAAC,GAEnC,IAAIrB,EAAMkW,EAAW/a,GAWrB,OAVW,MAAP6E,IACFA,EAAM5H,KAAK8U,UAAU/R,GAEjB,UAAe6E,GACjBA,EAAMA,EAAIvD,QACDuS,EAAShP,KAClBA,EAAM,SAAc,CAAC,EAAGA,IAE1BkW,EAAW/a,GAAO6E,GAEbA,CACT,EAEA4P,EAAWlX,UAAUuU,cAAgB,SAAU5L,EAAKlG,EAAKqH,GACvD,IAAI0T,EAAa9d,KAAKgY,aAAa/O,IAAQ,CAAC,EAC5CjJ,KAAKgY,aAAa/O,GAAO6U,EACrBlH,EAAS7T,GACX,SAAc+a,EAAY/a,GAE1B+a,EAAW/a,GAAOqH,CAEtB,EAKAoN,EAAWlX,UAAU4d,eAAiB,WACpCle,KAAK8X,QAAU,CAAC,EAChB9X,KAAKgY,aAAe,EACtB,EACAR,EAAWlX,UAAU0U,UAAY,SAAUjS,EAAK6E,GAC9CgP,EAAS7T,GAAO,SAAc/C,KAAK+X,QAAShV,GAAO/C,KAAK+X,QAAQhV,GAAO6E,CACzE,EAKA4P,EAAWlX,UAAU8U,UAAY,SAAUrS,GACzC,OAAO/C,KAAK+X,QAAQhV,EACtB,EAKAyU,EAAWlX,UAAU+U,cAAgB,SAAUpM,GAC7C,OAAOjJ,KAAKiY,aAAahP,EAC3B,EAKAuO,EAAWlX,UAAU6U,cAAgB,SAAUlM,EAAKgM,EAAQC,GAC1DlV,KAAKiY,aAAahP,GAAOiM,EAAQ,SAAclV,KAAKiY,aAAahP,IAAQ,CAAC,EAAGgM,GAAUA,CACzF,EAKAuC,EAAWlX,UAAU6d,iBAAmB,WACtCne,KAAKiY,aAAa3Y,OAAS,CAC7B,EAKAkY,EAAWlX,UAAU8d,iBAAmB,SAAUnV,EAAKoV,GACrD,IAAIC,EAActe,KAAK0X,WAAa1X,KAAK0X,UAAU4G,aACnD,OAAgBA,EAAate,KAAKue,SAAUtV,EAAKoV,GACjDre,KAAKkY,YAAYjP,GAAOoV,CAC1B,EACA7G,EAAWlX,UAAUiV,iBAAmB,SAAUtM,GAChD,OAAOjJ,KAAKkY,YAAYjP,EAC1B,EACAuO,EAAWlX,UAAUke,kBAAoB,SAAUrS,EAAIrM,GACrD,OAAYE,KAAKkY,aAAa,SAAUmG,EAAIpV,GACtCoV,GACFlS,GAAMA,EAAG/C,KAAKtJ,EAASue,EAAIpV,EAE/B,GACF,EAMAuO,EAAWlX,UAAUme,aAAe,SAAUjB,GAM5C,OALKA,IACHA,EAAO,IAAIhG,EAAWxX,KAAK2Y,QAAU3Y,KAAK2Y,QAAUhW,EAAI3C,KAAKgH,WAAYhH,KAAKua,YAAava,MAAOA,KAAK0X,YAEzGT,EAAmBuG,EAAMxd,MACzBwd,EAAKnC,OAASrb,KAAKqb,OACZmC,CACT,EAKAhG,EAAWlX,UAAUoe,WAAa,SAAUC,EAAYC,GACtD,IAAIC,EAAiB7e,KAAK2e,GACrB,aAAkBE,KAGvB7e,KAAK8e,iBAAmB9e,KAAK8e,kBAAoB,GACjD9e,KAAK8e,iBAAiB7b,KAAK0b,GAC3B3e,KAAK2e,GAAc,WACjB,IAAII,EAAMF,EAAepS,MAAMzM,KAAMsd,WACrC,OAAOsB,EAAenS,MAAMzM,KAAM,CAAC+e,GAAKC,OAAO,QAAa1B,YAC9D,EACF,EAIA9F,EAAW9G,cAAgB,WACzBmG,EAAuB,SAA8BtO,GACnD,IAAIuQ,EAAqBvQ,EAAKyR,oBAC9B,OAAYlB,GAAoB,SAAUiE,EAAiBxW,GACzD,IAAI4B,EAAUI,EAAKuR,UAAUvT,GAEzBc,EAAcc,EAAQd,YACtB9C,EAAQgE,EAAK8S,OACjB,GAAIhU,EAAa,CACf0V,EAAkBjE,EAAmBvS,GAAO,IAAI/C,EAAe6D,EAAYsO,WAAWrW,QAGtF,IAAK,IAAIqC,EAAI,EAAGA,EAAIob,EAAgBzd,OAAQqC,IAC1Cob,EAAgBpb,GAAK0V,EAEvB,IAAS1V,EAAI,EAAGA,EAAI4C,EAAMoC,QAAShF,IAEjCob,EAAgBxY,EAAM2C,IAAIiB,EAAQ0R,cAAelY,IAAMA,CAE3D,CACF,GACF,EACAoV,EAAqB,SAA4BxO,EAAM/D,EAAQyE,GAC7D,OAAO,QAAoBV,EAAKkU,aAAajY,EAAQyE,GAAM,KAC7D,EAKA6N,EAAQ,SAAevO,EAAMsC,GAC3B,IAAIoG,EAAK1I,EAAKsP,QAAQhN,GAOtB,OANU,MAANoG,GAAgC,MAAlB1I,EAAKqR,YACrB3I,EAAK8F,EAAmBxO,EAAMA,EAAKqR,UAAW/O,IAEtC,MAANoG,IACFA,EAAKmG,EAAYvM,GAEZoG,CACT,EACA+F,EAAsB,SAA6BhQ,GAIjD,OAHK,UAAeA,KAClBA,EAA2B,MAAdA,EAAqB,CAACA,GAAc,IAE5CA,CACT,EAKAkQ,EAA2B,SAAkCpG,GAC3D,IAAI0M,EAAO,IAAIhG,EAAW1G,EAAS6H,QAAU7H,EAAS6H,QAAUhW,EAAImO,EAAS9J,WAAY8J,EAASyJ,YAAazJ,GAAWA,EAAS4G,WAGnI,OADAT,EAAmBuG,EAAM1M,GAClB0M,CACT,EACAvG,EAAqB,SAA4B3J,EAAQtH,GACvD,OAAYsR,EAAwB0H,OAAOhZ,EAAO8Y,kBAAoB,KAAK,SAAUG,GAC/EjZ,EAAO2U,eAAesE,KACxB3R,EAAO2R,GAAYjZ,EAAOiZ,GAE9B,IACA3R,EAAOwR,iBAAmB9Y,EAAO8Y,iBACjC,OAAYvH,GAAkB,SAAU0H,GACtC3R,EAAO2R,GAAY,QAAajZ,EAAOiZ,GACzC,IACA3R,EAAO8K,iBAAmB,SAAc,CAAC,EAAGpS,EAAOoS,iBACrD,EACAjB,EAAiB,SAAwB5O,EAAMU,GAC7C,IAAIqS,EAAW/S,EAAKqP,UAChBoE,EAASzT,EAAKsP,QACdqH,EAAa3W,EAAKmR,YAClByF,EAAW5W,EAAKqR,UAChBT,EAAOmC,EAASrS,GAChBgI,EAAK+K,EAAO/S,GAOhB,GANY,MAARkQ,GAA8B,MAAd+F,IAClB5D,EAASrS,GAAOkQ,EAAOpC,EAAmBxO,EAAM2W,EAAYjW,IAEpD,MAANgI,GAA0B,MAAZkO,IAChBnD,EAAO/S,GAAOgI,EAAK8F,EAAmBxO,EAAM4W,EAAUlW,IAE9C,MAANgI,GAAsB,MAARkI,EAAc,CAC9B,IAAIiG,EAAkB7W,EAAKiT,iBACvB6D,EAAQD,EAAgBjG,IAASiG,EAAgBjG,IAAS,GAAK,EACnElI,EAAKkI,EACDkG,EAAQ,IACVpO,GAAM,SAAWoO,GAEnBrD,EAAO/S,GAAOgI,CAChB,CACF,CACF,CA1F2B,GA2FpBuG,CACT,CAl7BA,GAm7BA,Q,uCCz/BI8H,EAEJ,WAIE,SAASA,EAAsB5J,GAkC7B1V,KAAKuZ,UAAY,CAAC,EAEP,MAAP7D,GACFrD,EAAAA,OAAcrS,KAAM0V,EAExB,CAEA,OAAO4J,CACT,CA9CA,GAiDA,Q,mPC/CIC,EACJ,WACE,SAASA,EAAWC,GAClBxf,KAAKuI,KAAOiX,EAAOjX,OAASiX,EAAOpZ,eAAiB,KAA8B,CAAC,EAAI,IACvFpG,KAAKoG,aAAeoZ,EAAOpZ,cAAgB,KAE3CpG,KAAKyf,eAAiBD,EAAOC,gBAAkB,KAC/Czf,KAAK0f,WAAaF,EAAOE,YAAc,EACvC1f,KAAK2f,wBAA0BH,EAAOG,wBACtC3f,KAAK4f,cAAgBJ,EAAOI,cAC5B,IAAIC,EAAmB7f,KAAK6f,iBAAmBL,EAAOK,iBACtD,GAAIA,EACF,IAAK,IAAIle,EAAI,EAAGA,EAAIke,EAAiBvgB,OAAQqC,IAAK,CAChD,IAAI4E,EAAMsZ,EAAiBle,GACX,MAAZ4E,EAAIC,OACF,QAAaxG,KAAM2B,KAAO,YAC5B4E,EAAIC,KAAO,UAGjB,CAEJ,CACA,OAAO+Y,CACT,CAtBA,GAuBO,SAASO,EAAiBlY,GAC/B,OAAOA,aAAe2X,CACxB,CAMO,SAASQ,EAAaC,EAAYC,EAEzC7Z,GACEA,EAAeA,GAAgB8Z,EAAmBF,GAClD,IAAIP,EAAiBQ,EAAkBR,eACnCU,EAAaC,EAA0BJ,EAAY5Z,EAAcqZ,EAAgBQ,EAAkBI,aAAcJ,EAAkBjZ,YACnIhB,EAAS,IAAIuZ,EAAW,CAC1BhX,KAAMyX,EACN5Z,aAAcA,EACdqZ,eAAgBA,EAChBI,iBAAkBM,EAAWN,iBAC7BH,WAAYS,EAAWT,WACvBC,wBAAyBQ,EAAWR,wBACpCC,eAAe,IAAAxT,OAAM6T,KAEvB,OAAOja,CACT,CAKO,SAASsa,EAAiC/X,GAC/C,OAAO,IAAIgX,EAAW,CACpBhX,KAAMA,EACNnC,cAAc,IAAAma,cAAahY,GAAQ,KAA4B,MAEnE,CAKO,SAASiY,EAAmBxa,GACjC,OAAO,IAAIuZ,EAAW,CACpBhX,KAAMvC,EAAOuC,KACbnC,aAAcJ,EAAOI,aACrBqZ,eAAgBzZ,EAAOyZ,eACvBI,kBAAkB,IAAAzT,OAAMpG,EAAO6Z,kBAC/BH,WAAY1Z,EAAO0Z,WACnBC,wBAAyB3Z,EAAO2Z,yBAEpC,CAKO,SAASO,EAAmB3X,GACjC,IAAInC,EAAe,KACnB,IAAI,IAAAma,cAAahY,GACfnC,EAAe,UACV,IAAI,IAAAqa,SAAQlY,GAAO,CAEJ,IAAhBA,EAAKjJ,SACP8G,EAAe,MAEjB,IAAK,IAAIzE,EAAI,EAAG+F,EAAMa,EAAKjJ,OAAQqC,EAAI+F,EAAK/F,IAAK,CAC/C,IAAInC,EAAO+I,EAAK5G,GAChB,GAAY,MAARnC,EAAJ,CAEO,IAAI,IAAAihB,SAAQjhB,GAAO,CACxB4G,EAAe,KACf,KACF,CAAO,IAAI,IAAAwQ,UAASpX,GAAO,CACzB4G,EAAe,KACf,KACF,EACF,CACF,MAAO,IAAI,IAAAwQ,UAASrO,GAClB,IAAK,IAAIxF,KAAOwF,EACd,IAAI,IAAAmY,QAAOnY,EAAMxF,KAAQ,IAAA4d,aAAYpY,EAAKxF,IAAO,CAC/CqD,EAAe,KACf,KACF,CAGJ,OAAOA,CACT,CAMA,SAASga,EAA0B7X,EAAMnC,EAAcqZ,EAAgBY,EAMvER,GACE,IAAIF,EACAD,EAKJ,IAAKnX,EACH,MAAO,CACLsX,iBAAkBe,EAA0Bf,GAC5CH,WAAYA,EACZC,wBAAyBA,GAG7B,GAAIvZ,IAAiB,KAA0B,CAC7C,IAAIya,EAAgBtY,EAKC,SAAjB8X,GAA2C,MAAhBA,EAC7BS,GAAqB,SAAUlZ,GAElB,MAAPA,GAAuB,MAARA,KACb,IAAA8O,UAAS9O,GACG,MAAd8X,IAAuBA,EAAa,GAEpCA,EAAa,EAGnB,GAAGD,EAAgBoB,EAAe,IAElCnB,GAAa,IAAAqB,UAASV,GAAgBA,EAAeA,EAAe,EAAI,EAErER,GAAmC,IAAfH,IACvBG,EAAmB,GACnBiB,GAAqB,SAAUlZ,EAAK6O,GAClCoJ,EAAiBpJ,GAAgB,MAAP7O,EAAcA,EAAM,GAAK,EACrD,GAAG6X,EAAgBoB,EAAe7c,MAEpC2b,EAA0BE,EAAmBA,EAAiBvgB,OAASmgB,IAAmB,KAAuBoB,EAAcvhB,OAASuhB,EAAc,GAAKA,EAAc,GAAGvhB,OAAS,IACvL,MAAO,GAAI8G,IAAiB,KACrByZ,IACHA,EAAmBmB,EAA4BzY,SAE5C,GAAInC,IAAiB,KACrByZ,IACHA,EAAmB,IACnB,IAAAtV,MAAKhC,GAAM,SAAU0Y,EAAQle,GAC3B8c,EAAiB5c,KAAKF,EACxB,UAEG,GAAIqD,IAAiB,KAAwB,CAClD,IAAI8a,GAAS,QAAiB3Y,EAAK,IACnCoX,GAA0B,IAAAc,SAAQS,IAAWA,EAAO5hB,QAAU,CAChE,MAA4B,KAK5B,MAAO,CACLogB,WAAYA,EACZG,iBAAkBe,EAA0Bf,GAC5CF,wBAAyBA,EAE7B,CACA,SAASqB,EAA4BzY,GACnC,IACIgI,EADA4Q,EAAa,EAEjB,MAAOA,EAAa5Y,EAAKjJ,UAAYiR,EAAMhI,EAAK4Y,OAEhD,GAAI5Q,EACF,OAAO,IAAA1D,MAAK0D,EAEhB,CAIA,SAASqQ,EAA0Bf,GACjC,GAAKA,EAAL,CAIA,IAAIuB,GAAU,IAAA7b,iBACd,OAAO,IAAA5C,KAAIkd,GAAkB,SAAUwB,EAAS5K,GAC9C4K,GAAU,IAAAzK,UAASyK,GAAWA,EAAU,CACtClI,KAAMkI,GAGR,IAAI7hB,EAAO,CACT2Z,KAAMkI,EAAQlI,KACdmI,YAAaD,EAAQC,YACrB9a,KAAM6a,EAAQ7a,MAKhB,GAAiB,MAAbhH,EAAK2Z,KACP,OAAO3Z,EAGTA,EAAK2Z,MAAQ,GAMW,MAApB3Z,EAAK8hB,cACP9hB,EAAK8hB,YAAc9hB,EAAK2Z,MAE1B,IAAIoI,EAAQH,EAAQla,IAAI1H,EAAK2Z,MAQ7B,OAPKoI,EAKH/hB,EAAK2Z,MAAQ,IAAMoI,EAAM5a,QAJzBya,EAAQja,IAAI3H,EAAK2Z,KAAM,CACrBxS,MAAO,IAKJnH,CACT,GArCA,CAsCF,CACA,SAASshB,EAAqB3U,EAAIsT,EAAgBlX,EAAMiZ,GACtD,GAAI/B,IAAmB,KACrB,IAAK,IAAI9d,EAAI,EAAGA,EAAI4G,EAAKjJ,QAAUqC,EAAI6f,EAAS7f,IAC9CwK,EAAG5D,EAAK5G,GAAK4G,EAAK5G,GAAG,GAAK,KAAMA,OAGlC,KAAIuf,EAAS3Y,EAAK,IAAM,GACxB,IAAS5G,EAAI,EAAGA,EAAIuf,EAAO5hB,QAAUqC,EAAI6f,EAAS7f,IAChDwK,EAAG+U,EAAOvf,GAAIA,EAFU,CAK9B,CACO,SAAS8f,EAAyBzb,GACvC,IAAII,EAAeJ,EAAOI,aAC1B,OAAOA,IAAiB,MAA6BA,IAAiB,IACxE,C,oGC3PIsb,EAEJ,WACE,SAASA,EAASvI,EAAMwI,GACtB3hB,KAAK4hB,MAAQ,EACb5hB,KAAK6hB,OAAS,EASd7hB,KAAKyL,WAAa,EAClBzL,KAAK8hB,SAAW,GAChB9hB,KAAK+hB,aAAe,GACpB/hB,KAAKgiB,UAAW,EAChBhiB,KAAKmZ,KAAOA,GAAQ,GACpBnZ,KAAK2hB,SAAWA,CAClB,CAwOA,OAlOAD,EAASphB,UAAU2hB,UAAY,WAC7B,OAAOjiB,KAAKyL,UAAY,CAC1B,EAEAiW,EAASphB,UAAUuS,SAAW,SAAUqP,EAAS/V,EAAIrM,GAC/CuS,EAAAA,WAAkB6P,KACpBpiB,EAAUqM,EACVA,EAAK+V,EACLA,EAAU,MAGZA,EAAUA,GAAW,CAAC,EAElB7P,EAAAA,SAAgB6P,KAClBA,EAAU,CACRC,MAAOD,IAIX,IAEIE,EAFAD,EAAQD,EAAQC,OAAS,WACzBL,EAAW9hB,KAAKkiB,EAAQG,MAAQ,YAE1B,aAAVF,IAAyBC,EAAmBjW,EAAG/C,KAAKtJ,EAASE,OAE7D,IAAK,IAAI2B,EAAI,GAAIygB,GAAoBzgB,EAAImgB,EAASxiB,OAAQqC,IACxDmgB,EAASngB,GAAGkR,SAASqP,EAAS/V,EAAIrM,GAG1B,cAAVqiB,GAAyBhW,EAAG/C,KAAKtJ,EAASE,KAC5C,EAMA0hB,EAASphB,UAAUgiB,qBAAuB,SAAUV,GAClD,IAAIC,EAAS,EACb7hB,KAAK4hB,MAAQA,EAEb,IAAK,IAAIjgB,EAAI,EAAGA,EAAI3B,KAAK8hB,SAASxiB,OAAQqC,IAAK,CAC7C,IAAI4gB,EAAQviB,KAAK8hB,SAASngB,GAC1B4gB,EAAMD,qBAAqBV,EAAQ,GAE/BW,EAAMV,OAASA,IACjBA,EAASU,EAAMV,OAEnB,CAEA7hB,KAAK6hB,OAASA,EAAS,CACzB,EAEAH,EAASphB,UAAU0R,YAAc,SAAUf,GACzC,GAAIjR,KAAK8W,UAAY7F,EACnB,OAAOjR,KAGT,IAAK,IAAI2B,EAAI,EAAGmgB,EAAW9hB,KAAK8hB,SAAUpa,EAAMoa,EAASxiB,OAAQqC,EAAI+F,EAAK/F,IAAK,CAC7E,IAAIod,EAAM+C,EAASngB,GAAGqQ,YAAYf,GAElC,GAAI8N,EACF,OAAOA,CAEX,CACF,EAEA2C,EAASphB,UAAUkiB,SAAW,SAAU5Q,GACtC,GAAIA,IAAS5R,KACX,OAAO,EAGT,IAAK,IAAI2B,EAAI,EAAGmgB,EAAW9hB,KAAK8hB,SAAUpa,EAAMoa,EAASxiB,OAAQqC,EAAI+F,EAAK/F,IAAK,CAC7E,IAAIod,EAAM+C,EAASngB,GAAG6gB,SAAS5Q,GAE/B,GAAImN,EACF,OAAOA,CAEX,CACF,EAOA2C,EAASphB,UAAUmiB,aAAe,SAAUC,GAC1C,IAAIC,EAAY,GACZ/Q,EAAO8Q,EAAc1iB,KAAOA,KAAK4iB,WAErC,MAAOhR,EACL+Q,EAAU1f,KAAK2O,GACfA,EAAOA,EAAKgR,WAId,OADAD,EAAUE,UACHF,CACT,EAEAjB,EAASphB,UAAUwiB,oBAAsB,WACvC,IAAIhY,EAAU,GACViY,EAAW/iB,KAEf,MAAO+iB,EACLjY,EAAQ7H,KAAK8f,EAAStX,WACtBsX,EAAWA,EAASH,WAItB,OADA9X,EAAQ+X,UACD/X,CACT,EAEA4W,EAASphB,UAAU0iB,qBAAuB,WACxC,IAAIlY,EAAU,GAId,OAHA9K,KAAK6S,UAAS,SAAUoQ,GACtBnY,EAAQ7H,KAAKggB,EAAUxX,UACzB,IACOX,CACT,EAEA4W,EAASphB,UAAUmU,SAAW,SAAUlF,GACtC,IAAIhH,EAAOvI,KAAK2hB,SAASpZ,KACzB,OAAOA,EAAKmM,WAAWxN,IAAIqB,EAAKoM,kBAAkBpF,GAAa,SAAUvP,KAAKyL,UAChF,EAEAiW,EAASphB,UAAU0U,UAAY,SAAUC,EAAQC,GAC/ClV,KAAKyL,WAAa,GAAKzL,KAAK2hB,SAASpZ,KAAK4M,cAAcnV,KAAKyL,UAAWwJ,EAAQC,EAClF,EAMAwM,EAASphB,UAAU8U,UAAY,WAC7B,OAAOpV,KAAK2hB,SAASpZ,KAAK8M,cAAcrV,KAAKyL,UAC/C,EAKAiW,EAASphB,UAAUyT,SAAW,SAAUC,GACtC,KAAIhU,KAAKyL,UAAY,GAArB,CAIA,IAAIkW,EAAW3hB,KAAK2hB,SAChB1N,EAAY0N,EAASpZ,KAAK2L,aAAalU,KAAKyL,WAChD,OAAOwI,EAAUF,SAASC,EAJ1B,CAKF,EAGA0N,EAASphB,UAAU4iB,cAAgB,WACjC,OAAQljB,KAAK2hB,SAASwB,aAAe,IAAInjB,KAAK4hB,MAChD,EAEAF,EAASphB,UAAUsU,UAAY,SAAU7R,EAAKqH,GAC5CpK,KAAKyL,WAAa,GAAKzL,KAAK2hB,SAASpZ,KAAKsM,cAAc7U,KAAKyL,UAAW1I,EAAKqH,EAC/E,EAOAsX,EAASphB,UAAUwU,UAAY,SAAU/R,GACvC,OAAO/C,KAAK2hB,SAASpZ,KAAKwM,cAAc/U,KAAKyL,UAAW1I,EAC1D,EAEA2e,EAASphB,UAAUwF,YAAc,WAC/B,OAAO9F,KAAK2hB,SAASpZ,KAAKzC,YAAY9F,KAAKyL,UAC7C,EAEAiW,EAASphB,UAAUwW,MAAQ,WACzB,OAAO9W,KAAK2hB,SAASpZ,KAAKuO,MAAM9W,KAAKyL,UACvC,EAMAiW,EAASphB,UAAU8iB,cAAgB,WACjC,GAAIpjB,KAAK4iB,WAAY,CAGnB,IAFA,IAAId,EAAW9hB,KAAK4iB,WAAWd,SAEtBngB,EAAI,EAAGA,EAAImgB,EAASxiB,SAAUqC,EACrC,GAAImgB,EAASngB,KAAO3B,KAClB,OAAO2B,EAIX,OAAQ,CACV,CAEA,OAAQ,CACV,EASA+f,EAASphB,UAAU+iB,aAAe,SAAUzR,GAC1C,IAAI0R,EAAS1R,EAAKgR,WAElB,MAAOU,EAAQ,CACb,GAAIA,IAAWtjB,KACb,OAAO,EAGTsjB,EAASA,EAAOV,UAClB,CAEA,OAAO,CACT,EASAlB,EAASphB,UAAUijB,eAAiB,SAAU3R,GAC5C,OAAOA,IAAS5R,MAAQ4R,EAAKyR,aAAarjB,KAC5C,EAEO0hB,CACT,CA3PA,GAgQI8B,EAEJ,WACE,SAASA,EAAK9L,GACZ1X,KAAKwG,KAAO,OACZxG,KAAKyjB,OAAS,GACdzjB,KAAK0X,UAAYA,CACnB,CAkGA,OAhGA8L,EAAKljB,UAAUuS,SAAW,SAAUqP,EAAS/V,EAAIrM,GAC/CE,KAAK0jB,KAAK7Q,SAASqP,EAAS/V,EAAIrM,EAClC,EAEA0jB,EAAKljB,UAAUqjB,mBAAqB,SAAUlY,GAC5C,IAAIZ,EAAW7K,KAAKuI,KAAKzC,YAAY2F,GACrC,OAAOzL,KAAKyjB,OAAO5Y,EACrB,EAEA2Y,EAAKljB,UAAU0R,YAAc,SAAUmH,GACrC,OAAOnZ,KAAK0jB,KAAK1R,YAAYmH,EAC/B,EAOAqK,EAAKljB,UAAUI,OAAS,WAItB,IAHA,IAAI6H,EAAOvI,KAAKuI,KACZ6I,EAAQpR,KAAKyjB,OAER9hB,EAAI,EAAG+F,EAAM0J,EAAM9R,OAAQqC,EAAI+F,EAAK/F,IAC3CyP,EAAMzP,GAAG8J,WAAa,EAGxB,IAAS9J,EAAI,EAAG+F,EAAMa,EAAK5B,QAAShF,EAAI+F,EAAK/F,IAC3CyP,EAAM7I,EAAKzC,YAAYnE,IAAI8J,UAAY9J,CAE3C,EAMA6hB,EAAKljB,UAAUsjB,aAAe,WAC5B5jB,KAAKuI,KAAK4V,kBACZ,EAkBAqF,EAAKK,WAAa,SAAUC,EAAUpM,EAAWqM,GAC/C,IAAIC,EAAO,IAAIR,EAAK9L,GAChBuM,EAAW,GACXC,EAAS,EAGb,SAASC,EAAeC,EAAUxB,GAChC,IAAIxY,EAAQga,EAASha,MACrB8Z,EAASnc,KAAKE,IAAIic,EAAQ7R,EAAAA,QAAejI,GAASA,EAAM9K,OAAS,GACjE2kB,EAAShhB,KAAKmhB,GACd,IAAIxS,EAAO,IAAI8P,GAAS2C,EAAAA,EAAAA,IAAoBD,EAASjL,KAAM,IAAK6K,GAChEpB,EAAa0B,EAAS1S,EAAMgR,GAAcoB,EAAKN,KAAO9R,EAEtDoS,EAAKP,OAAOxgB,KAAK2O,GAEjB,IAAIkQ,EAAWsC,EAAStC,SAExB,GAAIA,EACF,IAAK,IAAIngB,EAAI,EAAGA,EAAImgB,EAASxiB,OAAQqC,IACnCwiB,EAAerC,EAASngB,GAAIiQ,EAGlC,CAlBAuS,EAAeL,GAoBfE,EAAKN,KAAKpB,qBAAqB,GAC/B,IAAItb,GAAaud,EAAAA,EAAAA,GAAwBN,EAAU,CACjDO,gBAAiB,CAAC,SAClBC,gBAAiBP,IAChBld,WACCwW,EAAO,IAAIhG,EAAAA,EAAWxQ,EAAY0Q,GAStC,OARA8F,EAAKhY,SAASye,GACdF,GAAcA,EAAWvG,IACzBkH,EAAAA,EAAAA,GAAe,CACbC,SAAUnH,EACVoH,OAAQZ,EACRa,WAAY,SAEdb,EAAKtjB,SACEsjB,CACT,EAEOR,CACT,CAxGA,GA+GA,SAASc,EAAS/B,EAAO3Q,GACvB,IAAIkQ,EAAWlQ,EAAKkQ,SAEhBS,EAAMK,aAAehR,IAIzBkQ,EAAS7e,KAAKsf,GACdA,EAAMK,WAAahR,EACrB,CAEA,Q","sources":["webpack://databoard/./node_modules/echarts/lib/data/DataDiffer.js","webpack://databoard/./node_modules/echarts/lib/data/DataStore.js","webpack://databoard/./node_modules/echarts/lib/data/Graph.js","webpack://databoard/./node_modules/echarts/lib/data/OrdinalMeta.js","webpack://databoard/./node_modules/echarts/lib/data/SeriesData.js","webpack://databoard/./node_modules/echarts/lib/data/SeriesDimensionDefine.js","webpack://databoard/./node_modules/echarts/lib/data/Source.js","webpack://databoard/./node_modules/echarts/lib/data/Tree.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;","import _typeof from \"D:/\\u9879\\u76EE\\u5730\\u5740/\\u770B\\u677F\\u9879\\u76EE/top-board/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = (typeof Uint32Array === \"undefined\" ? \"undefined\" : _typeof(Uint32Array)) === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = (typeof Uint16Array === \"undefined\" ? \"undefined\" : _typeof(Uint16Array)) === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = (typeof Int32Array === \"undefined\" ? \"undefined\" : _typeof(Int32Array)) === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = (typeof Float64Array === \"undefined\" ? \"undefined\" : _typeof(Float64Array)) === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n;\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n;\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore = /** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated until needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n    this._initDataFromProvider(0, provider.count());\n  };\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n    if (!provider.persistent) {\n      end += start;\n    }\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n    return [start, end];\n  };\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n    var emptyDataItem = [];\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retrieve the index with given raw data index.\n   */\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n    var left = 0;\n    var right = this._count - 1;\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -1;\n  };\n  /**\n   * Retrieve the index of nearest value.\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices have\n   *         the same value, they are put to the result.\n   */\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n    if (!dimData) {\n      return nearestIndices;\n    }\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we choose the one that `diff >= 0` in this case.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n    if (!len) {\n      return this;\n    }\n    var dims = keys(range);\n    var dimSize = dims.length;\n    if (!dimSize) {\n      return this;\n    }\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      }\n    }\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n    this._updateDims(target, dims, cb);\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (_typeof(retValue) !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          continue;\n        }\n        avgY += y;\n      }\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangle with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          countNaN++;\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n          continue;\n        } // Calculate triangle area over three buckets\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n      newIndices[offset++] = sampleFrameIdx;\n    }\n    target._count = offset;\n    target._indices = newIndices;\n    target._updateGetRawIdx();\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n        default:\n          var k = 0;\n          var value = [];\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n    dimExtent = this._extent[dim];\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n    this._copyCommonProps(target);\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n    target._updateGetRawIdx();\n    return target;\n  };\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n      return indices;\n    }\n    return null;\n  };\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n    return -1;\n  };\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function objectRows(dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function original(dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function typedArray(dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n  return DataStore;\n}();\nexport default DataStore;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js'; // id may be function name of Object, add a prefix to avoid this problem.\n\nfunction generateNodeKey(id) {\n  return '_EC_' + id;\n}\n\nvar Graph =\n/** @class */\nfunction () {\n  function Graph(directed) {\n    this.type = 'graph';\n    this.nodes = [];\n    this.edges = [];\n    this._nodesMap = {};\n    /**\n     * @type {Object.<string, module:echarts/data/Graph.Edge>}\n     * @private\n     */\n\n    this._edgesMap = {};\n    this._directed = directed || false;\n  }\n  /**\n   * If is directed graph\n   */\n\n\n  Graph.prototype.isDirected = function () {\n    return this._directed;\n  };\n\n  ;\n  /**\n   * Add a new node\n   */\n\n  Graph.prototype.addNode = function (id, dataIndex) {\n    id = id == null ? '' + dataIndex : '' + id;\n    var nodesMap = this._nodesMap;\n\n    if (nodesMap[generateNodeKey(id)]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Graph nodes have duplicate name or id');\n      }\n\n      return;\n    }\n\n    var node = new GraphNode(id, dataIndex);\n    node.hostGraph = this;\n    this.nodes.push(node);\n    nodesMap[generateNodeKey(id)] = node;\n    return node;\n  };\n\n  ;\n  /**\n   * Get node by data index\n   */\n\n  Graph.prototype.getNodeByIndex = function (dataIndex) {\n    var rawIdx = this.data.getRawIndex(dataIndex);\n    return this.nodes[rawIdx];\n  };\n\n  ;\n  /**\n   * Get node by id\n   */\n\n  Graph.prototype.getNodeById = function (id) {\n    return this._nodesMap[generateNodeKey(id)];\n  };\n\n  ;\n  /**\n   * Add a new edge\n   */\n\n  Graph.prototype.addEdge = function (n1, n2, dataIndex) {\n    var nodesMap = this._nodesMap;\n    var edgesMap = this._edgesMap; // PENDING\n\n    if (zrUtil.isNumber(n1)) {\n      n1 = this.nodes[n1];\n    }\n\n    if (zrUtil.isNumber(n2)) {\n      n2 = this.nodes[n2];\n    }\n\n    if (!(n1 instanceof GraphNode)) {\n      n1 = nodesMap[generateNodeKey(n1)];\n    }\n\n    if (!(n2 instanceof GraphNode)) {\n      n2 = nodesMap[generateNodeKey(n2)];\n    }\n\n    if (!n1 || !n2) {\n      return;\n    }\n\n    var key = n1.id + '-' + n2.id;\n    var edge = new GraphEdge(n1, n2, dataIndex);\n    edge.hostGraph = this;\n\n    if (this._directed) {\n      n1.outEdges.push(edge);\n      n2.inEdges.push(edge);\n    }\n\n    n1.edges.push(edge);\n\n    if (n1 !== n2) {\n      n2.edges.push(edge);\n    }\n\n    this.edges.push(edge);\n    edgesMap[key] = edge;\n    return edge;\n  };\n\n  ;\n  /**\n   * Get edge by data index\n   */\n\n  Graph.prototype.getEdgeByIndex = function (dataIndex) {\n    var rawIdx = this.edgeData.getRawIndex(dataIndex);\n    return this.edges[rawIdx];\n  };\n\n  ;\n  /**\n   * Get edge by two linked nodes\n   */\n\n  Graph.prototype.getEdge = function (n1, n2) {\n    if (n1 instanceof GraphNode) {\n      n1 = n1.id;\n    }\n\n    if (n2 instanceof GraphNode) {\n      n2 = n2.id;\n    }\n\n    var edgesMap = this._edgesMap;\n\n    if (this._directed) {\n      return edgesMap[n1 + '-' + n2];\n    } else {\n      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n    }\n  };\n\n  ;\n  /**\n   * Iterate all nodes\n   */\n\n  Graph.prototype.eachNode = function (cb, context) {\n    var nodes = this.nodes;\n    var len = nodes.length;\n\n    for (var i = 0; i < len; i++) {\n      if (nodes[i].dataIndex >= 0) {\n        cb.call(context, nodes[i], i);\n      }\n    }\n  };\n\n  ;\n  /**\n   * Iterate all edges\n   */\n\n  Graph.prototype.eachEdge = function (cb, context) {\n    var edges = this.edges;\n    var len = edges.length;\n\n    for (var i = 0; i < len; i++) {\n      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n        cb.call(context, edges[i], i);\n      }\n    }\n  };\n\n  ;\n  /**\n   * Breadth first traverse\n   * Return true to stop traversing\n   */\n\n  Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {\n    if (!(startNode instanceof GraphNode)) {\n      startNode = this._nodesMap[generateNodeKey(startNode)];\n    }\n\n    if (!startNode) {\n      return;\n    }\n\n    var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].__visited = false;\n    }\n\n    if (cb.call(context, startNode, null)) {\n      return;\n    }\n\n    var queue = [startNode];\n\n    while (queue.length) {\n      var currentNode = queue.shift();\n      var edges = currentNode[edgeType];\n\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n\n        if (!otherNode.__visited) {\n          if (cb.call(context, otherNode, currentNode)) {\n            // Stop traversing\n            return;\n          }\n\n          queue.push(otherNode);\n          otherNode.__visited = true;\n        }\n      }\n    }\n  };\n\n  ; // TODO\n  // depthFirstTraverse(\n  //     cb, startNode, direction, context\n  // ) {\n  // };\n  // Filter update\n\n  Graph.prototype.update = function () {\n    var data = this.data;\n    var edgeData = this.edgeData;\n    var nodes = this.nodes;\n    var edges = this.edges;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n\n    edgeData.filterSelf(function (idx) {\n      var edge = edges[edgeData.getRawIndex(idx)];\n      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n    }); // Update edge\n\n    for (var i = 0, len = edges.length; i < len; i++) {\n      edges[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = edgeData.count(); i < len; i++) {\n      edges[edgeData.getRawIndex(i)].dataIndex = i;\n    }\n  };\n\n  ;\n  /**\n   * @return {module:echarts/data/Graph}\n   */\n\n  Graph.prototype.clone = function () {\n    var graph = new Graph(this._directed);\n    var nodes = this.nodes;\n    var edges = this.edges;\n\n    for (var i = 0; i < nodes.length; i++) {\n      graph.addNode(nodes[i].id, nodes[i].dataIndex);\n    }\n\n    for (var i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n    }\n\n    return graph;\n  };\n\n  ;\n  return Graph;\n}();\n\nvar GraphNode =\n/** @class */\nfunction () {\n  function GraphNode(id, dataIndex) {\n    this.inEdges = [];\n    this.outEdges = [];\n    this.edges = [];\n    this.dataIndex = -1;\n    this.id = id == null ? '' : id;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  GraphNode.prototype.degree = function () {\n    return this.edges.length;\n  };\n  /**\n   * @return {number}\n   */\n\n\n  GraphNode.prototype.inDegree = function () {\n    return this.inEdges.length;\n  };\n  /**\n  * @return {number}\n  */\n\n\n  GraphNode.prototype.outDegree = function () {\n    return this.outEdges.length;\n  };\n\n  GraphNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var graph = this.hostGraph;\n    var itemModel = graph.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n\n  GraphNode.prototype.getAdjacentDataIndices = function () {\n    var dataIndices = {\n      edge: [],\n      node: []\n    };\n\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n\n      dataIndices.edge.push(adjacentEdge.dataIndex);\n      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);\n    }\n\n    return dataIndices;\n  };\n\n  return GraphNode;\n}();\n\nvar GraphEdge =\n/** @class */\nfunction () {\n  function GraphEdge(n1, n2, dataIndex) {\n    this.dataIndex = -1;\n    this.node1 = n1;\n    this.node2 = n2;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  GraphEdge.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var graph = this.hostGraph;\n    var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n\n  GraphEdge.prototype.getAdjacentDataIndices = function () {\n    return {\n      edge: [this.dataIndex],\n      node: [this.node1.dataIndex, this.node2.dataIndex]\n    };\n  };\n\n  return GraphEdge;\n}();\n\nfunction createGraphDataProxyMixin(hostName, dataName) {\n  return {\n    /**\n     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\n     */\n    getValue: function (dimension) {\n      var data = this[hostName][dataName];\n      return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n    },\n    // TODO: TYPE stricter type.\n    setVisual: function (key, value) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n    },\n    getVisual: function (key) {\n      return this[hostName][dataName].getItemVisual(this.dataIndex, key);\n    },\n    setLayout: function (layout, merge) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n    },\n    getLayout: function () {\n      return this[hostName][dataName].getItemLayout(this.dataIndex);\n    },\n    getGraphicEl: function () {\n      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n    },\n    getRawIndex: function () {\n      return this[hostName][dataName].getRawIndex(this.dataIndex);\n    }\n  };\n}\n\n;\n;\n;\nzrUtil.mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));\nzrUtil.mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\nexport default Graph;\nexport { GraphNode, GraphEdge };","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, map, isString } from 'zrender/lib/core/util.js';\nvar uidBase = 0;\n\nvar OrdinalMeta =\n/** @class */\nfunction () {\n  function OrdinalMeta(opt) {\n    this.categories = opt.categories || [];\n    this._needCollect = opt.needCollect;\n    this._deduplication = opt.deduplication;\n    this.uid = ++uidBase;\n  }\n\n  OrdinalMeta.createByAxisModel = function (axisModel) {\n    var option = axisModel.option;\n    var data = option.data;\n    var categories = data && map(data, getName);\n    return new OrdinalMeta({\n      categories: categories,\n      needCollect: !categories,\n      // deduplication is default in axis.\n      deduplication: option.dedplication !== false\n    });\n  };\n\n  ;\n\n  OrdinalMeta.prototype.getOrdinal = function (category) {\n    // @ts-ignore\n    return this._getOrCreateMap().get(category);\n  };\n  /**\n   * @return The ordinal. If not found, return NaN.\n   */\n\n\n  OrdinalMeta.prototype.parseAndCollect = function (category) {\n    var index;\n    var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.\n    // This feature is only supported when !needCollect, because we should\n    // consider a common case: a value is 2017, which is a number but is\n    // expected to be tread as a category. This case usually happen in dataset,\n    // where it happent to be no need of the index feature.\n\n    if (!isString(category) && !needCollect) {\n      return category;\n    } // Optimize for the scenario:\n    // category is ['2012-01-01', '2012-01-02', ...], where the input\n    // data has been ensured not duplicate and is large data.\n    // Notice, if a dataset dimension provide categroies, usually echarts\n    // should remove duplication except user tell echarts dont do that\n    // (set axis.deduplication = false), because echarts do not know whether\n    // the values in the category dimension has duplication (consider the\n    // parallel-aqi example)\n\n\n    if (needCollect && !this._deduplication) {\n      index = this.categories.length;\n      this.categories[index] = category;\n      return index;\n    }\n\n    var map = this._getOrCreateMap(); // @ts-ignore\n\n\n    index = map.get(category);\n\n    if (index == null) {\n      if (needCollect) {\n        index = this.categories.length;\n        this.categories[index] = category; // @ts-ignore\n\n        map.set(category, index);\n      } else {\n        index = NaN;\n      }\n    }\n\n    return index;\n  }; // Consider big data, do not create map until needed.\n\n\n  OrdinalMeta.prototype._getOrCreateMap = function () {\n    return this._map || (this._map = createHashMap(this.categories));\n  };\n\n  return OrdinalMeta;\n}();\n\nfunction getName(obj) {\n  if (isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nexport default OrdinalMeta;","import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\nvar SeriesData = /** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n    this._initGetDimensionInfo(needsHasOwn);\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx == null) {\n      return dim;\n    }\n    dimIdx = dim;\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n    if (dimName != null) {\n      return dimName;\n    }\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n    if (dim == null) {\n      return -1;\n    }\n    var dimInfo = this._getDimInfo(dim);\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n    var store;\n    if (data instanceof DataStore) {\n      store = data;\n    }\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n      start = _a.start,\n      end = _a.end;\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n    this._updateOrdinalMeta();\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n    var store = this._store;\n    var provider = store.getProvider();\n    this._updateOrdinalMeta();\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n        if (dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n    var rawIndex = invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  }; // eslint-disable-next-line\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function prepareInvertedIndex(data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function getIdNameFromStore(data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n    getId = function getId(data, rawIndex) {\n      var id = data._idList[rawIndex];\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function normalizeDimensions(dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n    cloneListForMapAndSample = function cloneListForMapAndSample(original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n    transferProperties = function transferProperties(target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function makeIdFromName(data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return SeriesData;\n}();\nexport default SeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\n\nvar SeriesDimensionDefine =\n/** @class */\nfunction () {\n  /**\n   * @param opt All of the fields will be shallow copied.\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\n     * The format of `otherDims` is:\n     * ```js\n     * {\n     *     tooltip?: number\n     *     label?: number\n     *     itemName?: number\n     *     seriesName?: number\n     * }\n     * ```\n     *\n     * A `series.encode` can specified these fields:\n     * ```js\n     * encode: {\n     *     // \"3, 1, 5\" is the index of data dimension.\n     *     tooltip: [3, 1, 5],\n     *     label: [0, 3],\n     *     ...\n     * }\n     * ```\n     * `otherDims` is the parse result of the `series.encode` above, like:\n     * ```js\n     * // Suppose the index of this data dimension is `3`.\n     * this.otherDims = {\n     *     // `3` is at the index `0` of the `encode.tooltip`\n     *     tooltip: 0,\n     *     // `3` is at the index `1` of the `encode.label`\n     *     label: 1\n     * };\n     * ```\n     *\n     * This prop should never be `null`/`undefined` after initialized.\n     */\n    this.otherDims = {};\n\n    if (opt != null) {\n      zrUtil.extend(this, opt);\n    }\n  }\n\n  return SeriesDimensionDefine;\n}();\n\n;\nexport default SeriesDimensionDefine;","import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { isTypedArray, clone, createHashMap, isArray, isObject, isArrayLike, hasOwn, assert, each, map, isNumber, isString, keys } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_UNKNOWN, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW } from '../util/types.js';\nimport { getDataItemValue } from '../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './helper/sourceHelper.js';\n; // @inner\n\nvar SourceImpl = /** @class */\nfunction () {\n  function SourceImpl(fields) {\n    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);\n    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN; // Visit config\n\n    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;\n    this.startIndex = fields.startIndex || 0;\n    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;\n    this.metaRawOption = fields.metaRawOption;\n    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;\n    if (dimensionsDefine) {\n      for (var i = 0; i < dimensionsDefine.length; i++) {\n        var dim = dimensionsDefine[i];\n        if (dim.type == null) {\n          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {\n            dim.type = 'ordinal';\n          }\n        }\n      }\n    }\n  }\n  return SourceImpl;\n}();\nexport function isSourceInstance(val) {\n  return val instanceof SourceImpl;\n}\n/**\n * Create a source from option.\n * NOTE: Created source is immutable. Don't change any properties in it.\n */\n\nexport function createSource(sourceData, thisMetaRawOption,\n// can be null. If not provided, auto detect it from `sourceData`.\nsourceFormat) {\n  sourceFormat = sourceFormat || detectSourceFormat(sourceData);\n  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;\n  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);\n  var source = new SourceImpl({\n    data: sourceData,\n    sourceFormat: sourceFormat,\n    seriesLayoutBy: seriesLayoutBy,\n    dimensionsDefine: determined.dimensionsDefine,\n    startIndex: determined.startIndex,\n    dimensionsDetectedCount: determined.dimensionsDetectedCount,\n    metaRawOption: clone(thisMetaRawOption)\n  });\n  return source;\n}\n/**\n * Wrap original series data for some compatibility cases.\n */\n\nexport function createSourceFromSeriesDataOption(data) {\n  return new SourceImpl({\n    data: data,\n    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL\n  });\n}\n/**\n * Clone source but excludes source data.\n */\n\nexport function cloneSourceShallow(source) {\n  return new SourceImpl({\n    data: source.data,\n    sourceFormat: source.sourceFormat,\n    seriesLayoutBy: source.seriesLayoutBy,\n    dimensionsDefine: clone(source.dimensionsDefine),\n    startIndex: source.startIndex,\n    dimensionsDetectedCount: source.dimensionsDetectedCount\n  });\n}\n/**\n * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.\n */\n\nexport function detectSourceFormat(data) {\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (hasOwn(data, key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  }\n  return sourceFormat;\n}\n/**\n * Determine the source definitions from data standalone dimensions definitions\n * are not specified.\n */\n\nfunction determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader,\n// standalone raw dimensions definition, like:\n// {\n//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]\n// }\n// in `dataset` or `series`\ndimensionsDefine) {\n  var dimensionsDetectedCount;\n  var startIndex; // PENDING: Could data be null/undefined here?\n  // currently, if `dataset.source` not specified, error thrown.\n  // if `series.data` not specified, nothing rendered without error thrown.\n  // Should test these cases.\n\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n      startIndex: startIndex,\n      dimensionsDetectedCount: dimensionsDetectedCount\n    };\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data; // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n      }, seriesLayoutBy, dataArrayRows, 10);\n    } else {\n      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;\n    }\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val + '' : '';\n      }, seriesLayoutBy, dataArrayRows, Infinity);\n    }\n    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectedCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');\n    }\n  }\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n    dimensionsDetectedCount: dimensionsDetectedCount\n  };\n}\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n  if (obj) {\n    return keys(obj);\n  }\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefined or string.\n\nfunction normalizeDimensionsOption(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (rawItem, index) {\n    rawItem = isObject(rawItem) ? rawItem : {\n      name: rawItem\n    }; // Other fields will be discarded.\n\n    var item = {\n      name: rawItem.name,\n      displayName: rawItem.displayName,\n      type: rawItem.type\n    }; // User can set null in dimensions.\n    // We don't auto specify name, otherwise a given name may\n    // cause it to be referred unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n    var exist = nameMap.get(item.name);\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n    return item;\n  });\n}\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\nexport function shouldRetrieveDataByName(source) {\n  var sourceFormat = source.sourceFormat;\n  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Tree data structure\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport linkSeriesData from './helper/linkSeriesData.js';\nimport SeriesData from './SeriesData.js';\nimport prepareSeriesDataSchema from './helper/createDimensions.js';\nimport { convertOptionIdName } from '../util/model.js';\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     */\n\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\n   * The node is removed.\n   */\n\n\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrUtil.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\n   * Update depth and height of this subtree.\n   */\n\n\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n\n    this.height = height + 1;\n  };\n\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\n   * @param includeSelf Default false.\n   * @return order: [root, child, grandchild, ...]\n   */\n\n\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n\n    ancestors.reverse();\n    return ancestors;\n  };\n\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n\n    indices.reverse();\n    return indices;\n  };\n\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\n   * @return {Object} layout\n   */\n\n\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  }; // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  }; // TODO: TYPE More specific model\n\n\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\n   * Get item visual\n   * FIXME: make return type better\n   */\n\n\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\n   * index in parent's children\n   */\n\n\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    return -1;\n  };\n  /**\n   * if this is an ancestor of another node\n   *\n   * @param node another node\n   * @return if is ancestor\n   */\n\n\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return false;\n  };\n  /**\n   * if this is an descendant of another node\n   *\n   * @param node another node\n   * @return if is descendant\n   */\n\n\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n\n  return TreeNode;\n}();\n\nexport { TreeNode };\n;\n\nvar Tree =\n/** @class */\nfunction () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n\n\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\n   * Clear all layouts\n   */\n\n\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\n   * data node format:\n   * {\n   *     name: ...\n   *     value: ...\n   *     children: [\n   *         {\n   *             name: ...\n   *             value: ...\n   *             children: ...\n   *         },\n   *         ...\n   *     ]\n   * }\n   */\n\n\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n\n      tree._nodes.push(node);\n\n      var children = dataNode.children;\n\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = prepareSeriesDataSchema(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new SeriesData(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    linkSeriesData({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n\n  return Tree;\n}();\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n */\n\n\nfunction addChild(child, node) {\n  var children = node.children;\n\n  if (child.parentNode === node) {\n    return;\n  }\n\n  children.push(child);\n  child.parentNode = node;\n}\n\nexport default Tree;"],"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","this","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push","defaultDimValueGetters","UNDEFINED","CtorUint32Array","Uint32Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","newStore","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","createHashMap","initData","provider","inputDimensions","dimValueGetter","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","_dimensions","dim","type","property","_initDataFromProvider","count","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","getItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","getByRawIndex","rawIdx","getSum","dimData","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","clone","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","keys","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","maxArea","area","nextRawIndex","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","dimExtent","currEnd","useRaw","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","reduce","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","objectRows","keyedColumns","original","typedArray","generateNodeKey","id","Graph","directed","nodes","edges","_nodesMap","_edgesMap","_directed","isDirected","addNode","nodesMap","node","GraphNode","hostGraph","getNodeByIndex","getNodeById","addEdge","n1","n2","edgesMap","zrUtil","edge","GraphEdge","outEdges","inEdges","getEdgeByIndex","edgeData","getEdge","eachNode","eachEdge","node1","node2","breadthFirstTraverse","startNode","direction","edgeType","__visited","queue","currentNode","e","otherNode","filterSelf","graph","degree","inDegree","outDegree","getModel","path","itemModel","getItemModel","getAdjacentDataIndices","dataIndices","adjacentEdge","createGraphDataProxyMixin","hostName","dataName","getValue","getStore","getDimensionIndex","setVisual","setItemVisual","getVisual","getItemVisual","setLayout","layout","merge","setItemLayout","getLayout","getItemLayout","getGraphicEl","getItemGraphicEl","uidBase","OrdinalMeta","opt","categories","_needCollect","needCollect","_deduplication","deduplication","uid","createByAxisModel","axisModel","option","getName","dedplication","getOrdinal","category","_getOrCreateMap","index","isString","_map","isObject","prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","ID_PREFIX","INDEX_NOT_FOUND","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","SeriesData","dimensionsInput","hostModel","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","assignStoreDimIdx","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","dimInfoInput","dimensionInfo","name","dimensionName","coordDim","coordDimIndex","otherDims","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","getDimension","_recognizeDimIndex","sourceDimDef","getSourceDimension","_getDimInfo","getSourceDimensionIndex","_getStoreDimIndex","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","mapDimension","dimensionsSummary","encodeFirstDimNotExtra","encode","mapDimensionsAll","_store","nameList","_this","_nameRepeatCount","_doInit","userOutput","names","_a","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","idList","isFormatOriginal","pure","sharedDataItem","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","setCalculationInfo","_getCategory","ordinal","hasValue","dataDimIndicesOnCoord","indexOfName","rawIndexOf","invertedIndices","ctx","fCtx","dimIndices","innerRange","mapArray","result","arguments","ctxCompat","list","ecModel","otherList","thisList","visual","kvObj","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","clearAllVisual","clearItemLayouts","setItemGraphicEl","el","seriesIndex","dataType","eachItemGraphicEl","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","propName","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt","SeriesDimensionDefine","SourceImpl","fields","seriesLayoutBy","startIndex","dimensionsDetectedCount","metaRawOption","dimensionsDefine","isSourceInstance","createSource","sourceData","thisMetaRawOption","detectSourceFormat","determined","determineSourceDimensions","sourceHeader","createSourceFromSeriesDataOption","isTypedArray","cloneSourceShallow","isArray","hasOwn","isArrayLike","normalizeDimensionsOption","dataArrayRows","arrayRowsTravelFirst","isNumber","objectRowsCollectDimensions","colArr","value0","firstIndex","nameMap","rawItem","displayName","exist","maxLoop","shouldRetrieveDataByName","TreeNode","hostTree","depth","height","children","viewChildren","isExpand","isRemoved","options","order","suppressVisitSub","attr","updateDepthAndHeight","child","contains","getAncestors","includeSelf","ancestors","parentNode","reverse","getAncestorsIndices","currNode","getDescendantIndices","childNode","getLevelModel","levelModels","getChildIndex","isAncestorOf","parent","isDescendantOf","Tree","_nodes","root","getNodeByDataIndex","clearLayouts","createTree","dataRoot","beforeLink","tree","listData","dimMax","buildHierarchy","dataNode","convertOptionIdName","addChild","prepareSeriesDataSchema","coordDimensions","dimensionsCount","linkSeriesData","mainData","struct","structAttr"],"sourceRoot":""}